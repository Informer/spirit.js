{"version":3,"sources":["header.js","Lodash.js","Helpers.js","Globals.js","Timeline.js","Events.js","Abstract.js","Group.js","State.js","Transition.js","TransitionParam.js","RegExpMapping.js","Groups.js","States.js","Timelines.js","TransitionParams.js","Transitions.js","AnimateTo.js","api.js","footer.js"],"names":[],"mappings":"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","file":"spirit.min.js","sourcesContent":["/*!\n * Spirit 0.1.0 (http://spiritjs.io/)\n * Copyright 2013 - 2015 Inlet.\n * Licensed under Apache 2.0 (https://github.com/inlet/spirit.js/blob/master/LICENSE)\n */\n\n(function(global){\n\n\t/**\n\t * Object to store namespace in\n\t * This will eventually be exposed on window or returned as module\n\t * @type {Object}\n\t */\n\tvar context = {\n\t\tspirit: {\n\t\t\tVERSION: \"0.1.0\"\n\t\t}\n\t};\n\n  /**\n   * Do not expose this object publicly\n   * Only for internal use.\n   * @type {Object}\n   */\n  var contextInternally = {};\n\n\t/**\n\t * Resolves namespace\n\t * @param {String} namespace\n   * @param {Boolean} expose public\n\t * @returns {Object} recursive namespace\n\t */\n\tvar use = function(namespace, exposePublic) {\n\n\t\tvar segments = namespace.split('.');\n\n\t\tfor (var i = 0, len = segments.length, obj = (exposePublic ? context : contextInternally); i < len; ++i) {\n\t\t\tvar segment = segments[i];\n\t\t\tif (!obj[segment]) {\n\t\t\t\tobj[segment] = {};\n\t\t\t}\n\t\t\tobj = obj[segment];\n\t\t}\n\n\t\treturn obj;\n\t};\n\n\t/**\n\t * Check if namespace exists\n\t * @param {String} namespace (example spirit.model.fixture)\n\t * @returns {Boolean}\n\t */\n\tvar exist = function(namespace, exposePublic) {\n\t\tif (typeof namespace !== 'string') {\n\t\t\treturn false;\n\t\t}\n\t\tvar segments = namespace.split('.');\n\t\tvar doesExist = true;\n\n\t\tfor (var i = 0, len = segments.length, obj = (exposePublic ? context : contextInternally); i < len; ++i) {\n\t\t\tvar segment = segments[i];\n\n\t\t\tif (!obj[segment]) {\n\t\t\t\tdoesExist = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tobj = obj[segment];\n\t\t}\n\n\t\treturn doesExist;\n\t};\n","/**\n * Lo-Dash 2.2.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash underscore exports=\"amd,commonjs,global,node\" -o ./dist/lodash.underscore.js`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/* jshint ignore:start */\n\n(function(ns){\n\n    (function() {\n\n\n\n    \t/** Used as a safe reference for `undefined` in pre ES5 environments */\n    \tvar undefined;\n\n    \t/** Used to generate unique IDs */\n    \tvar idCounter = 0;\n\n    \t/** Used internally to indicate various things */\n    \tvar indicatorObject = {};\n\n    \t/** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */\n    \tvar keyPrefix = +new Date + '';\n\n    \t/** Used to match \"interpolate\" template delimiters */\n    \tvar reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n    \t/** Used to ensure capturing order of template delimiters */\n    \tvar reNoMatch = /($^)/;\n\n    \t/** Used to match unescaped characters in compiled string literals */\n    \tvar reUnescapedString = /['\\n\\r\\t\\u2028\\u2029\\\\]/g;\n\n    \t/** `Object#toString` result shortcuts */\n    \tvar argsClass = '[object Arguments]',\n    \t\tarrayClass = '[object Array]',\n    \t\tboolClass = '[object Boolean]',\n    \t\tdateClass = '[object Date]',\n    \t\tfuncClass = '[object Function]',\n    \t\tnumberClass = '[object Number]',\n    \t\tobjectClass = '[object Object]',\n    \t\tregexpClass = '[object RegExp]',\n    \t\tstringClass = '[object String]';\n\n    \t/** Used to determine if values are of the language type Object */\n    \tvar objectTypes = {\n    \t\t'boolean': false,\n    \t\t'function': true,\n    \t\t'object': true,\n    \t\t'number': false,\n    \t\t'string': false,\n    \t\t'undefined': false\n    \t};\n\n    \t/** Used to escape characters for inclusion in compiled string literals */\n    \tvar stringEscapes = {\n    \t\t'\\\\': '\\\\',\n    \t\t\"'\": \"'\",\n    \t\t'\\n': 'n',\n    \t\t'\\r': 'r',\n    \t\t'\\t': 't',\n    \t\t'\\u2028': 'u2028',\n    \t\t'\\u2029': 'u2029'\n    \t};\n\n    \t/** Used as a reference to the global object */\n    \tvar root = (objectTypes[typeof window] && window) || this;\n\n    \t/** Detect free variable `exports` */\n    \tvar freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n    \t/** Detect free variable `module` */\n    \tvar freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n    \t/** Detect the popular CommonJS extension `module.exports` */\n    \tvar moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n    \t/** Detect free variable `global` from Node.js or Browserified code and use it as `root` */\n    \tvar freeGlobal = objectTypes[typeof global] && global;\n    \tif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    \t\troot = freeGlobal;\n    \t}\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t/**\n    \t * The base implementation of `_.indexOf` without support for binary searches\n    \t * or `fromIndex` constraints.\n    \t *\n    \t * @private\n    \t * @param {Array} array The array to search.\n    \t * @param {*} value The value to search for.\n    \t * @param {number} [fromIndex=0] The index to search from.\n    \t * @returns {number} Returns the index of the matched value or `-1`.\n    \t */\n    \tfunction baseIndexOf(array, value, fromIndex) {\n    \t\tvar index = (fromIndex || 0) - 1,\n    \t\t\tlength = array ? array.length : 0;\n\n    \t\twhile (++index < length) {\n    \t\t\tif (array[index] === value) {\n    \t\t\t\treturn index;\n    \t\t\t}\n    \t\t}\n    \t\treturn -1;\n    \t}\n\n    \t/**\n    \t * Used by `sortBy` to compare transformed `collection` elements, stable sorting\n    \t * them in ascending order.\n    \t *\n    \t * @private\n    \t * @param {Object} a The object to compare to `b`.\n    \t * @param {Object} b The object to compare to `a`.\n    \t * @returns {number} Returns the sort order indicator of `1` or `-1`.\n    \t */\n    \tfunction compareAscending(a, b) {\n    \t\tvar ac = a.criteria,\n    \t\t\tbc = b.criteria;\n\n    \t\t// ensure a stable sort in V8 and other engines\n    \t\t// http://code.google.com/p/v8/issues/detail?id=90\n    \t\tif (ac !== bc) {\n    \t\t\tif (ac > bc || typeof ac == 'undefined') {\n    \t\t\t\treturn 1;\n    \t\t\t}\n    \t\t\tif (ac < bc || typeof bc == 'undefined') {\n    \t\t\t\treturn -1;\n    \t\t\t}\n    \t\t}\n    \t\t// The JS engine embedded in Adobe applications like InDesign has a buggy\n    \t\t// `Array#sort` implementation that causes it, under certain circumstances,\n    \t\t// to return the same value for `a` and `b`.\n    \t\t// See https://github.com/jashkenas/underscore/pull/1247\n    \t\treturn a.index - b.index;\n    \t}\n\n    \t/**\n    \t * Used by `template` to escape characters for inclusion in compiled\n    \t * string literals.\n    \t *\n    \t * @private\n    \t * @param {string} match The matched character to escape.\n    \t * @returns {string} Returns the escaped character.\n    \t */\n    \tfunction escapeStringChar(match) {\n    \t\treturn '\\\\' + stringEscapes[match];\n    \t}\n\n    \t/**\n    \t * A no-operation function.\n    \t *\n    \t * @private\n    \t */\n    \tfunction noop() {\n    \t\t// no operation performed\n    \t}\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t/**\n    \t * Used for `Array` method references.\n    \t *\n    \t * Normally `Array.prototype` would suffice, however, using an array literal\n    \t * avoids issues in Narwhal.\n    \t */\n    \tvar arrayRef = [];\n\n    \t/** Used for native method references */\n    \tvar objectProto = Object.prototype;\n\n    \t/** Used to restore the original `_` reference in `noConflict` */\n    \tvar oldDash = root._;\n\n    \t/** Used to detect if a method is native */\n    \tvar reNative = RegExp('^' +\n    \t\tString(objectProto.valueOf)\n    \t\t\t.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    \t\t\t.replace(/valueOf|for [^\\]]+/g, '.+?') + '$'\n    \t);\n\n    \t/** Native method shortcuts */\n    \tvar ceil = Math.ceil,\n    \t\tfloor = Math.floor,\n    \t\thasOwnProperty = objectProto.hasOwnProperty,\n    \t\tnow = reNative.test(now = Date.now) && now || function() { return +new Date; },\n    \t\tpush = arrayRef.push,\n    \t\ttoString = objectProto.toString,\n    \t\tunshift = arrayRef.unshift;\n\n    \t/* Native method shortcuts for methods with the same name as other `lodash` methods */\n    \tvar nativeBind = reNative.test(nativeBind = toString.bind) && nativeBind,\n    \t\tnativeCreate = reNative.test(nativeCreate = Object.create) && nativeCreate,\n    \t\tnativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray,\n    \t\tnativeIsFinite = root.isFinite,\n    \t\tnativeIsNaN = root.isNaN,\n    \t\tnativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys,\n    \t\tnativeMax = Math.max,\n    \t\tnativeMin = Math.min,\n    \t\tnativeRandom = Math.random,\n    \t\tnativeSlice = arrayRef.slice;\n\n    \t/** Detect various environments */\n    \tvar isIeOpera = reNative.test(root.attachEvent),\n    \t\tisV8 = nativeBind && !/\\n|true/.test(nativeBind + isIeOpera);\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t/**\n    \t * Creates a `lodash` object which wraps the given value to enable intuitive\n    \t * method chaining.\n    \t *\n    \t * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:\n    \t * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,\n    \t * and `unshift`\n    \t *\n    \t * Chaining is supported in custom builds as long as the `value` method is\n    \t * implicitly or explicitly included in the build.\n    \t *\n    \t * The chainable wrapper functions are:\n    \t * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,\n    \t * `compose`, `concat`, `countBy`, `createCallback`, `curry`, `debounce`,\n    \t * `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`, `forEach`,\n    \t * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,\n    \t * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,\n    \t * `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`, `once`, `pairs`,\n    \t * `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`, `range`, `reject`,\n    \t * `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`, `sortBy`, `splice`,\n    \t * `tap`, `throttle`, `times`, `toArray`, `transform`, `union`, `uniq`, `unshift`,\n    \t * `unzip`, `values`, `where`, `without`, `wrap`, and `zip`\n    \t *\n    \t * The non-chainable wrapper functions are:\n    \t * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,\n    \t * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,\n    \t * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n    \t * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,\n    \t * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,\n    \t * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,\n    \t * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,\n    \t * `template`, `unescape`, `uniqueId`, and `value`\n    \t *\n    \t * The wrapper functions `first` and `last` return wrapped values when `n` is\n    \t * provided, otherwise they return unwrapped values.\n    \t *\n    \t * Explicit chaining can be enabled by using the `_.chain` method.\n    \t *\n    \t * @name _\n    \t * @constructor\n    \t * @category Chaining\n    \t * @param {*} value The value to wrap in a `lodash` instance.\n    \t * @returns {Object} Returns a `lodash` instance.\n    \t * @example\n    \t *\n    \t * var wrapped = _([1, 2, 3]);\n    \t *\n    \t * // returns an unwrapped value\n    \t * wrapped.reduce(function(sum, num) {\n       *   return sum + num;\n       * });\n    \t * // => 6\n    \t *\n    \t * // returns a wrapped value\n    \t * var squares = wrapped.map(function(num) {\n       *   return num * num;\n       * });\n    \t *\n    \t * _.isArray(squares);\n    \t * // => false\n    \t *\n    \t * _.isArray(squares.value());\n    \t * // => true\n    \t */\n    \tfunction lodash(value) {\n    \t\treturn (value instanceof lodash)\n    \t\t\t? value\n    \t\t\t: new lodashWrapper(value);\n    \t}\n\n    \t/**\n    \t * A fast path for creating `lodash` wrapper objects.\n    \t *\n    \t * @private\n    \t * @param {*} value The value to wrap in a `lodash` instance.\n    \t * @param {boolean} chainAll A flag to enable chaining for all methods\n    \t * @returns {Object} Returns a `lodash` instance.\n    \t */\n    \tfunction lodashWrapper(value, chainAll) {\n    \t\tthis.__chain__ = !!chainAll;\n    \t\tthis.__wrapped__ = value;\n    \t}\n    \t// ensure `new lodashWrapper` is an instance of `lodash`\n    \tlodashWrapper.prototype = lodash.prototype;\n\n    \t/**\n    \t * An object used to flag environments features.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @type Object\n    \t */\n    \tvar support = {};\n\n    \t(function() {\n    \t\tvar object = { '0': 1, 'length': 1 };\n\n    \t\t/**\n    \t\t * Detect if `Function#bind` exists and is inferred to be fast (all but V8).\n    \t\t *\n    \t\t * @memberOf _.support\n    \t\t * @type boolean\n    \t\t */\n    \t\tsupport.fastBind = nativeBind && !isV8;\n\n    \t\t/**\n    \t\t * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.\n    \t\t *\n    \t\t * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`\n    \t\t * and `splice()` functions that fail to remove the last element, `value[0]`,\n    \t\t * of array-like objects even though the `length` property is set to `0`.\n    \t\t * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`\n    \t\t * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.\n    \t\t *\n    \t\t * @memberOf _.support\n    \t\t * @type boolean\n    \t\t */\n    \t\tsupport.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);\n    \t}(1));\n\n    \t/**\n    \t * By default, the template delimiters used by Lo-Dash are similar to those in\n    \t * embedded Ruby (ERB). Change the following template settings to use alternative\n    \t * delimiters.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @type Object\n    \t */\n    \tlodash.templateSettings = {\n\n    \t\t/**\n    \t\t * Used to detect `data` property values to be HTML-escaped.\n    \t\t *\n    \t\t * @memberOf _.templateSettings\n    \t\t * @type RegExp\n    \t\t */\n    \t\t'escape': /<%-([\\s\\S]+?)%>/g,\n\n    \t\t/**\n    \t\t * Used to detect code to be evaluated.\n    \t\t *\n    \t\t * @memberOf _.templateSettings\n    \t\t * @type RegExp\n    \t\t */\n    \t\t'evaluate': /<%([\\s\\S]+?)%>/g,\n\n    \t\t/**\n    \t\t * Used to detect `data` property values to inject.\n    \t\t *\n    \t\t * @memberOf _.templateSettings\n    \t\t * @type RegExp\n    \t\t */\n    \t\t'interpolate': reInterpolate,\n\n    \t\t/**\n    \t\t * Used to reference the data object in the template text.\n    \t\t *\n    \t\t * @memberOf _.templateSettings\n    \t\t * @type string\n    \t\t */\n    \t\t'variable': ''\n    \t};\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t/**\n    \t * The base implementation of `_.createCallback` without support for creating\n    \t * \"_.pluck\" or \"_.where\" style callbacks.\n    \t *\n    \t * @private\n    \t * @param {*} [func=identity] The value to convert to a callback.\n    \t * @param {*} [thisArg] The `this` binding of the created callback.\n    \t * @param {number} [argCount] The number of arguments the callback accepts.\n    \t * @returns {Function} Returns a callback function.\n    \t */\n    \tfunction baseCreateCallback(func, thisArg, argCount) {\n    \t\tif (typeof func != 'function') {\n    \t\t\treturn identity;\n    \t\t}\n    \t\t// exit early if there is no `thisArg`\n    \t\tif (typeof thisArg == 'undefined') {\n    \t\t\treturn func;\n    \t\t}\n    \t\tswitch (argCount) {\n    \t\t\tcase 1: return function(value) {\n    \t\t\t\treturn func.call(thisArg, value);\n    \t\t\t};\n    \t\t\tcase 2: return function(a, b) {\n    \t\t\t\treturn func.call(thisArg, a, b);\n    \t\t\t};\n    \t\t\tcase 3: return function(value, index, collection) {\n    \t\t\t\treturn func.call(thisArg, value, index, collection);\n    \t\t\t};\n    \t\t\tcase 4: return function(accumulator, value, index, collection) {\n    \t\t\t\treturn func.call(thisArg, accumulator, value, index, collection);\n    \t\t\t};\n    \t\t}\n    \t\treturn bind(func, thisArg);\n    \t}\n\n    \t/**\n    \t * The base implementation of `_.flatten` without support for callback\n    \t * shorthands or `thisArg` binding.\n    \t *\n    \t * @private\n    \t * @param {Array} array The array to flatten.\n    \t * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n    \t * @param {boolean} [isArgArrays=false] A flag to restrict flattening to arrays and `arguments` objects.\n    \t * @param {number} [fromIndex=0] The index to start from.\n    \t * @returns {Array} Returns a new flattened array.\n    \t */\n    \tfunction baseFlatten(array, isShallow, isArgArrays, fromIndex) {\n    \t\tvar index = (fromIndex || 0) - 1,\n    \t\t\tlength = array ? array.length : 0,\n    \t\t\tresult = [];\n\n    \t\twhile (++index < length) {\n    \t\t\tvar value = array[index];\n\n    \t\t\tif (value && typeof value == 'object' && typeof value.length == 'number'\n    \t\t\t\t&& (isArray(value) || isArguments(value))) {\n    \t\t\t\t// recursively flatten arrays (susceptible to call stack limits)\n    \t\t\t\tif (!isShallow) {\n    \t\t\t\t\tvalue = baseFlatten(value, isShallow, isArgArrays);\n    \t\t\t\t}\n    \t\t\t\tvar valIndex = -1,\n    \t\t\t\t\tvalLength = value.length,\n    \t\t\t\t\tresIndex = result.length;\n\n    \t\t\t\tresult.length += valLength;\n    \t\t\t\twhile (++valIndex < valLength) {\n    \t\t\t\t\tresult[resIndex++] = value[valIndex];\n    \t\t\t\t}\n    \t\t\t} else if (!isArgArrays) {\n    \t\t\t\tresult.push(value);\n    \t\t\t}\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * The base implementation of `_.isEqual`, without support for `thisArg` binding,\n    \t * that allows partial \"_.where\" style comparisons.\n    \t *\n    \t * @private\n    \t * @param {*} a The value to compare.\n    \t * @param {*} b The other value to compare.\n    \t * @param {Function} [callback] The function to customize comparing values.\n    \t * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.\n    \t * @param {Array} [stackA=[]] Tracks traversed `a` objects.\n    \t * @param {Array} [stackB=[]] Tracks traversed `b` objects.\n    \t * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n    \t */\n    \tfunction baseIsEqual(a, b, stackA, stackB) {\n    \t\tif (a === b) {\n    \t\t\treturn a !== 0 || (1 / a == 1 / b);\n    \t\t}\n    \t\tvar type = typeof a,\n    \t\t\totherType = typeof b;\n\n    \t\tif (a === a &&\n    \t\t\t!(a && objectTypes[type]) &&\n    \t\t\t!(b && objectTypes[otherType])) {\n    \t\t\treturn false;\n    \t\t}\n    \t\tif (a == null || b == null) {\n    \t\t\treturn a === b;\n    \t\t}\n    \t\tvar className = toString.call(a),\n    \t\t\totherClass = toString.call(b);\n\n    \t\tif (className != otherClass) {\n    \t\t\treturn false;\n    \t\t}\n    \t\tswitch (className) {\n    \t\t\tcase boolClass:\n    \t\t\tcase dateClass:\n    \t\t\t\treturn +a == +b;\n\n    \t\t\tcase numberClass:\n    \t\t\t\treturn a != +a\n    \t\t\t\t\t? b != +b\n    \t\t\t\t\t: (a == 0 ? (1 / a == 1 / b) : a == +b);\n\n    \t\t\tcase regexpClass:\n    \t\t\tcase stringClass:\n    \t\t\t\treturn a == String(b);\n    \t\t}\n    \t\tvar isArr = className == arrayClass;\n    \t\tif (!isArr) {\n    \t\t\tif (hasOwnProperty.call(a, '__wrapped__ ') || b instanceof lodash) {\n    \t\t\t\treturn baseIsEqual(a.__wrapped__ || a, b.__wrapped__ || b, stackA, stackB);\n    \t\t\t}\n    \t\t\tif (className != objectClass) {\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t\tvar ctorA = a.constructor,\n    \t\t\t\tctorB = b.constructor;\n\n    \t\t\tif (ctorA != ctorB && !(\n    \t\t\t\tisFunction(ctorA) && ctorA instanceof ctorA &&\n    \t\t\t\t\tisFunction(ctorB) && ctorB instanceof ctorB\n    \t\t\t\t)) {\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t}\n    \t\tstackA || (stackA = []);\n    \t\tstackB || (stackB = []);\n\n    \t\tvar length = stackA.length;\n    \t\twhile (length--) {\n    \t\t\tif (stackA[length] == a) {\n    \t\t\t\treturn stackB[length] == b;\n    \t\t\t}\n    \t\t}\n    \t\tvar result = true,\n    \t\t\tsize = 0;\n\n    \t\tstackA.push(a);\n    \t\tstackB.push(b);\n\n    \t\tif (isArr) {\n    \t\t\tsize = b.length;\n    \t\t\tresult = size == a.length;\n\n    \t\t\tif (result) {\n    \t\t\t\twhile (size--) {\n    \t\t\t\t\tif (!(result = baseIsEqual(a[size], b[size], stackA, stackB))) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn result;\n    \t\t}\n    \t\tforIn(b, function(value, key, b) {\n    \t\t\tif (hasOwnProperty.call(b, key)) {\n    \t\t\t\tsize++;\n    \t\t\t\treturn !(result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, stackA, stackB)) && indicatorObject;\n    \t\t\t}\n    \t\t});\n\n    \t\tif (result) {\n    \t\t\tforIn(a, function(value, key, a) {\n    \t\t\t\tif (hasOwnProperty.call(a, key)) {\n    \t\t\t\t\treturn !(result = --size > -1) && indicatorObject;\n    \t\t\t\t}\n    \t\t\t});\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * The base implementation of `_.uniq` without support for callback shorthands\n    \t * or `thisArg` binding.\n    \t *\n    \t * @private\n    \t * @param {Array} array The array to process.\n    \t * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n    \t * @param {Function} [callback] The function called per iteration.\n    \t * @returns {Array} Returns a duplicate-value-free array.\n    \t */\n    \tfunction baseUniq(array, isSorted, callback) {\n    \t\tvar index = -1,\n    \t\t\tindexOf = getIndexOf(),\n    \t\t\tlength = array ? array.length : 0,\n    \t\t\tresult = [],\n    \t\t\tseen = callback ? [] : result;\n\n    \t\twhile (++index < length) {\n    \t\t\tvar value = array[index],\n    \t\t\t\tcomputed = callback ? callback(value, index, array) : value;\n\n    \t\t\tif (isSorted\n    \t\t\t\t? !index || seen[seen.length - 1] !== computed\n    \t\t\t\t: indexOf(seen, computed) < 0\n    \t\t\t\t) {\n    \t\t\t\tif (callback) {\n    \t\t\t\t\tseen.push(computed);\n    \t\t\t\t}\n    \t\t\t\tresult.push(value);\n    \t\t\t}\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Creates a function that aggregates a collection, creating an object composed\n    \t * of keys generated from the results of running each element of the collection\n    \t * through a callback. The given `setter` function sets the keys and values\n    \t * of the composed object.\n    \t *\n    \t * @private\n    \t * @param {Function} setter The setter function.\n    \t * @returns {Function} Returns the new aggregator function.\n    \t */\n    \tfunction createAggregator(setter) {\n    \t\treturn function(collection, callback, thisArg) {\n    \t\t\tvar result = {};\n    \t\t\tcallback = createCallback(callback, thisArg, 3);\n\n    \t\t\tvar index = -1,\n    \t\t\t\tlength = collection ? collection.length : 0;\n\n    \t\t\tif (typeof length == 'number') {\n    \t\t\t\twhile (++index < length) {\n    \t\t\t\t\tvar value = collection[index];\n    \t\t\t\t\tsetter(result, value, callback(value, index, collection), collection);\n    \t\t\t\t}\n    \t\t\t} else {\n    \t\t\t\tforOwn(collection, function(value, key, collection) {\n    \t\t\t\t\tsetter(result, value, callback(value, key, collection), collection);\n    \t\t\t\t});\n    \t\t\t}\n    \t\t\treturn result;\n    \t\t};\n    \t}\n\n    \t/**\n    \t * Creates a function that, when called, either curries or invokes `func`\n    \t * with an optional `this` binding and partially applied arguments.\n    \t *\n    \t * @private\n    \t * @param {Function|string} func The function or method name to reference.\n    \t * @param {number} bitmask The bitmask of method flags to compose.\n    \t *  The bitmask may be composed of the following flags:\n    \t *  1 - `_.bind`\n    \t *  2 - `_.bindKey`\n    \t *  4 - `_.curry`\n    \t *  8 - `_.curry` (bound)\n    \t *  16 - `_.partial`\n    \t *  32 - `_.partialRight`\n    \t * @param {Array} [partialArgs] An array of arguments to prepend to those\n    \t *  provided to the new function.\n    \t * @param {Array} [partialRightArgs] An array of arguments to append to those\n    \t *  provided to the new function.\n    \t * @param {*} [thisArg] The `this` binding of `func`.\n    \t * @param {number} [arity] The arity of `func`.\n    \t * @returns {Function} Returns the new bound function.\n    \t */\n    \tfunction createBound(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {\n    \t\tvar isBind = bitmask & 1,\n    \t\t\tisBindKey = bitmask & 2,\n    \t\t\tisCurry = bitmask & 4,\n    \t\t\tisCurryBound = bitmask & 8,\n    \t\t\tisPartial = bitmask & 16,\n    \t\t\tisPartialRight = bitmask & 32,\n    \t\t\tkey = func;\n\n    \t\tif (!isBindKey && !isFunction(func)) {\n    \t\t\tthrow new TypeError;\n    \t\t}\n    \t\tif (isPartial && !partialArgs.length) {\n    \t\t\tbitmask &= ~16;\n    \t\t\tisPartial = partialArgs = false;\n    \t\t}\n    \t\tif (isPartialRight && !partialRightArgs.length) {\n    \t\t\tbitmask &= ~32;\n    \t\t\tisPartialRight = partialRightArgs = false;\n    \t\t}\n    \t\t// use `Function#bind` if it exists and is fast\n    \t\t// (in V8 `Function#bind` is slower except when partially applied)\n    \t\tif (isBind && !(isBindKey || isCurry || isPartialRight) &&\n    \t\t\t(support.fastBind || (nativeBind && isPartial))) {\n    \t\t\tif (isPartial) {\n    \t\t\t\tvar args = [thisArg];\n    \t\t\t\tpush.apply(args, partialArgs);\n    \t\t\t}\n    \t\t\tvar bound = isPartial\n    \t\t\t\t? nativeBind.apply(func, args)\n    \t\t\t\t: nativeBind.call(func, thisArg);\n    \t\t}\n    \t\telse {\n    \t\t\tbound = function() {\n    \t\t\t\t// `Function#bind` spec\n    \t\t\t\t// http://es5.github.io/#x15.3.4.5\n    \t\t\t\tvar args = arguments,\n    \t\t\t\t\tthisBinding = isBind ? thisArg : this;\n\n    \t\t\t\tif (isCurry || isPartial || isPartialRight) {\n    \t\t\t\t\targs = nativeSlice.call(args);\n    \t\t\t\t\tif (isPartial) {\n    \t\t\t\t\t\tunshift.apply(args, partialArgs);\n    \t\t\t\t\t}\n    \t\t\t\t\tif (isPartialRight) {\n    \t\t\t\t\t\tpush.apply(args, partialRightArgs);\n    \t\t\t\t\t}\n    \t\t\t\t\tif (isCurry && args.length < arity) {\n    \t\t\t\t\t\tbitmask |= 16 & ~32;\n    \t\t\t\t\t\treturn createBound(func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity);\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tif (isBindKey) {\n    \t\t\t\t\tfunc = thisBinding[key];\n    \t\t\t\t}\n    \t\t\t\tif (this instanceof bound) {\n    \t\t\t\t\t// ensure `new bound` is an instance of `func`\n    \t\t\t\t\tthisBinding = createObject(func.prototype);\n\n    \t\t\t\t\t// mimic the constructor's `return` behavior\n    \t\t\t\t\t// http://es5.github.io/#x13.2.2\n    \t\t\t\t\tvar result = func.apply(thisBinding, args);\n    \t\t\t\t\treturn isObject(result) ? result : thisBinding;\n    \t\t\t\t}\n    \t\t\t\treturn func.apply(thisBinding, args);\n    \t\t\t};\n    \t\t}\n    \t\treturn bound;\n    \t}\n\n    \t/**\n    \t * Creates a new object with the specified `prototype`.\n    \t *\n    \t * @private\n    \t * @param {Object} prototype The prototype object.\n    \t * @returns {Object} Returns the new object.\n    \t */\n    \tfunction createObject(prototype) {\n    \t\treturn isObject(prototype) ? nativeCreate(prototype) : {};\n    \t}\n    \t// fallback for browsers without `Object.create`\n    \tif (!nativeCreate) {\n    \t\tcreateObject = function(prototype) {\n    \t\t\tif (isObject(prototype)) {\n    \t\t\t\tnoop.prototype = prototype;\n    \t\t\t\tvar result = new noop;\n    \t\t\t\tnoop.prototype = null;\n    \t\t\t}\n    \t\t\treturn result || {};\n    \t\t};\n    \t}\n\n    \t/**\n    \t * Used by `escape` to convert characters to HTML entities.\n    \t *\n    \t * @private\n    \t * @param {string} match The matched character to escape.\n    \t * @returns {string} Returns the escaped character.\n    \t */\n    \tfunction escapeHtmlChar(match) {\n    \t\treturn htmlEscapes[match];\n    \t}\n\n    \t/**\n    \t * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n    \t * customized, this method returns the custom method, otherwise it returns\n    \t * the `baseIndexOf` function.\n    \t *\n    \t * @private\n    \t * @returns {Function} Returns the \"indexOf\" function.\n    \t */\n    \tfunction getIndexOf() {\n    \t\tvar result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Used by `unescape` to convert HTML entities to characters.\n    \t *\n    \t * @private\n    \t * @param {string} match The matched character to unescape.\n    \t * @returns {string} Returns the unescaped character.\n    \t */\n    \tfunction unescapeHtmlChar(match) {\n    \t\treturn htmlUnescapes[match];\n    \t}\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t/**\n    \t * Checks if `value` is an `arguments` object.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.\n    \t * @example\n    \t *\n    \t * (function() { return _.isArguments(arguments); })(1, 2, 3);\n    \t * // => true\n    \t *\n    \t * _.isArguments([1, 2, 3]);\n    \t * // => false\n    \t */\n    \tfunction isArguments(value) {\n    \t\treturn value && typeof value == 'object' && typeof value.length == 'number' &&\n    \t\t\ttoString.call(value) == argsClass || false;\n    \t}\n    \t// fallback for browsers that can't detect `arguments` objects by [[Class]]\n    \tif (!isArguments(arguments)) {\n    \t\tisArguments = function(value) {\n    \t\t\treturn value && typeof value == 'object' && typeof value.length == 'number' &&\n    \t\t\t\thasOwnProperty.call(value, 'callee') || false;\n    \t\t};\n    \t}\n\n    \t/**\n    \t * Checks if `value` is an array.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @type Function\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is an array, else `false`.\n    \t * @example\n    \t *\n    \t * (function() { return _.isArray(arguments); })();\n    \t * // => false\n    \t *\n    \t * _.isArray([1, 2, 3]);\n    \t * // => true\n    \t */\n    \tvar isArray = nativeIsArray || function(value) {\n    \t\treturn value && typeof value == 'object' && typeof value.length == 'number' &&\n    \t\t\ttoString.call(value) == arrayClass || false;\n    \t};\n\n    \t/**\n    \t * A fallback implementation of `Object.keys` which produces an array of the\n    \t * given object's own enumerable property names.\n    \t *\n    \t * @private\n    \t * @type Function\n    \t * @param {Object} object The object to inspect.\n    \t * @returns {Array} Returns an array of property names.\n    \t */\n    \tvar shimKeys = function(object) {\n    \t\tvar index, iterable = object, result = [];\n    \t\tif (!iterable) return result;\n    \t\tif (!(objectTypes[typeof object])) return result;\n    \t\tfor (index in iterable) {\n    \t\t\tif (hasOwnProperty.call(iterable, index)) {\n    \t\t\t\tresult.push(index);\n    \t\t\t}\n    \t\t}\n    \t\treturn result\n    \t};\n\n    \t/**\n    \t * Creates an array composed of the own enumerable property names of an object.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {Object} object The object to inspect.\n    \t * @returns {Array} Returns an array of property names.\n    \t * @example\n    \t *\n    \t * _.keys({ 'one': 1, 'two': 2, 'three': 3 });\n    \t * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)\n    \t */\n    \tvar keys = !nativeKeys ? shimKeys : function(object) {\n    \t\tif (!isObject(object)) {\n    \t\t\treturn [];\n    \t\t}\n    \t\treturn nativeKeys(object);\n    \t};\n\n    \t/**\n    \t * Used to convert characters to HTML entities:\n    \t *\n    \t * Though the `>` character is escaped for symmetry, characters like `>` and `/`\n    \t * don't require escaping in HTML and have no special meaning unless they're part\n    \t * of a tag or an unquoted attribute value.\n    \t * http://mathiasbynens.be/notes/ambiguous-ampersands (under \"semi-related fun fact\")\n    \t */\n    \tvar htmlEscapes = {\n    \t\t'&': '&amp;',\n    \t\t'<': '&lt;',\n    \t\t'>': '&gt;',\n    \t\t'\"': '&quot;',\n    \t\t\"'\": '&#x27;'\n    \t};\n\n    \t/** Used to convert HTML entities to characters */\n    \tvar htmlUnescapes = invert(htmlEscapes);\n\n    \t/** Used to match HTML entities and HTML characters */\n    \tvar reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),\n    \t\treUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t/**\n    \t * Assigns own enumerable properties of source object(s) to the destination\n    \t * object. Subsequent sources will overwrite property assignments of previous\n    \t * sources. If a callback is provided it will be executed to produce the\n    \t * assigned values. The callback is bound to `thisArg` and invoked with two\n    \t * arguments; (objectValue, sourceValue).\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @type Function\n    \t * @alias extend\n    \t * @category Objects\n    \t * @param {Object} object The destination object.\n    \t * @param {...Object} [source] The source objects.\n    \t * @param {Function} [callback] The function to customize assigning values.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Object} Returns the destination object.\n    \t * @example\n    \t *\n    \t * _.assign({ 'name': 'moe' }, { 'age': 40 });\n    \t * // => { 'name': 'moe', 'age': 40 }\n    \t *\n    \t * var defaults = _.partialRight(_.assign, function(a, b) {\n       *   return typeof a == 'undefined' ? b : a;\n       * });\n    \t *\n    \t * var food = { 'name': 'apple' };\n    \t * defaults(food, { 'name': 'banana', 'type': 'fruit' });\n    \t * // => { 'name': 'apple', 'type': 'fruit' }\n    \t */\n    \tfunction assign(object) {\n    \t\tif (!object) {\n    \t\t\treturn object;\n    \t\t}\n    \t\tfor (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {\n    \t\t\tvar iterable = arguments[argsIndex];\n    \t\t\tif (iterable) {\n    \t\t\t\tfor (var key in iterable) {\n    \t\t\t\t\tobject[key] = iterable[key];\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn object;\n    \t}\n\n    \t/**\n    \t * Creates a clone of `value`. If `deep` is `true` nested objects will also\n    \t * be cloned, otherwise they will be assigned by reference. If a callback\n    \t * is provided it will be executed to produce the cloned values. If the\n    \t * callback returns `undefined` cloning will be handled by the method instead.\n    \t * The callback is bound to `thisArg` and invoked with one argument; (value).\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to clone.\n    \t * @param {boolean} [deep=false] Specify a deep clone.\n    \t * @param {Function} [callback] The function to customize cloning values.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {*} Returns the cloned value.\n    \t * @example\n    \t *\n    \t * var stooges = [\n    \t *   { 'name': 'moe', 'age': 40 },\n    \t *   { 'name': 'larry', 'age': 50 }\n    \t * ];\n    \t *\n    \t * var shallow = _.clone(stooges);\n    \t * shallow[0] === stooges[0];\n    \t * // => true\n    \t *\n    \t * var deep = _.clone(stooges, true);\n    \t * deep[0] === stooges[0];\n    \t * // => false\n    \t *\n    \t * _.mixin({\n       *   'clone': _.partialRight(_.clone, function(value) {\n       *     return _.isElement(value) ? value.cloneNode(false) : undefined;\n       *   })\n       * });\n    \t *\n    \t * var clone = _.clone(document.body);\n    \t * clone.childNodes.length;\n    \t * // => 0\n    \t */\n    \tfunction clone(value) {\n    \t\treturn isObject(value)\n    \t\t\t? (isArray(value) ? nativeSlice.call(value) : assign({}, value))\n    \t\t\t: value;\n    \t}\n\n    \t/**\n    \t * Assigns own enumerable properties of source object(s) to the destination\n    \t * object for all destination properties that resolve to `undefined`. Once a\n    \t * property is set, additional defaults of the same property will be ignored.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @type Function\n    \t * @category Objects\n    \t * @param {Object} object The destination object.\n    \t * @param {...Object} [source] The source objects.\n    \t * @param- {Object} [guard] Allows working with `_.reduce` without using its\n    \t *  `key` and `object` arguments as sources.\n    \t * @returns {Object} Returns the destination object.\n    \t * @example\n    \t *\n    \t * var food = { 'name': 'apple' };\n    \t * _.defaults(food, { 'name': 'banana', 'type': 'fruit' });\n    \t * // => { 'name': 'apple', 'type': 'fruit' }\n    \t */\n    \tfunction defaults(object) {\n    \t\tif (!object) {\n    \t\t\treturn object;\n    \t\t}\n    \t\tfor (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {\n    \t\t\tvar iterable = arguments[argsIndex];\n    \t\t\tif (iterable) {\n    \t\t\t\tfor (var key in iterable) {\n    \t\t\t\t\tif (typeof object[key] == 'undefined') {\n    \t\t\t\t\t\tobject[key] = iterable[key];\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn object;\n    \t}\n\n    \t/**\n    \t * Iterates over own and inherited enumerable properties of an object,\n    \t * executing the callback for each property. The callback is bound to `thisArg`\n    \t * and invoked with three arguments; (value, key, object). Callbacks may exit\n    \t * iteration early by explicitly returning `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @type Function\n    \t * @category Objects\n    \t * @param {Object} object The object to iterate over.\n    \t * @param {Function} [callback=identity] The function called per iteration.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Object} Returns `object`.\n    \t * @example\n    \t *\n    \t * function Dog(name) {\n       *   this.name = name;\n       * }\n    \t *\n    \t * Dog.prototype.bark = function() {\n       *   console.log('Woof, woof!');\n       * };\n    \t *\n    \t * _.forIn(new Dog('Dagny'), function(value, key) {\n       *   console.log(key);\n       * });\n    \t * // => logs 'bark' and 'name' (property order is not guaranteed across environments)\n    \t */\n    \tvar forIn = function(collection, callback) {\n    \t\tvar index, iterable = collection, result = iterable;\n    \t\tif (!iterable) return result;\n    \t\tif (!objectTypes[typeof iterable]) return result;\n    \t\tfor (index in iterable) {\n    \t\t\tif (callback(iterable[index], index, collection) === indicatorObject) return result;\n    \t\t}\n    \t\treturn result\n    \t};\n\n    \t/**\n    \t * Iterates over own enumerable properties of an object, executing the callback\n    \t * for each property. The callback is bound to `thisArg` and invoked with three\n    \t * arguments; (value, key, object). Callbacks may exit iteration early by\n    \t * explicitly returning `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @type Function\n    \t * @category Objects\n    \t * @param {Object} object The object to iterate over.\n    \t * @param {Function} [callback=identity] The function called per iteration.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Object} Returns `object`.\n    \t * @example\n    \t *\n    \t * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n       *   console.log(key);\n       * });\n    \t * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)\n    \t */\n    \tvar forOwn = function(collection, callback) {\n    \t\tvar index, iterable = collection, result = iterable;\n    \t\tif (!iterable) return result;\n    \t\tif (!objectTypes[typeof iterable]) return result;\n    \t\tfor (index in iterable) {\n    \t\t\tif (hasOwnProperty.call(iterable, index)) {\n    \t\t\t\tif (callback(iterable[index], index, collection) === indicatorObject) return result;\n    \t\t\t}\n    \t\t}\n    \t\treturn result\n    \t};\n\n    \t/**\n    \t * Creates a sorted array of property names of all enumerable properties,\n    \t * own and inherited, of `object` that have function values.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias methods\n    \t * @category Objects\n    \t * @param {Object} object The object to inspect.\n    \t * @returns {Array} Returns an array of property names that have function values.\n    \t * @example\n    \t *\n    \t * _.functions(_);\n    \t * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]\n    \t */\n    \tfunction functions(object) {\n    \t\tvar result = [];\n    \t\tforIn(object, function(value, key) {\n    \t\t\tif (isFunction(value)) {\n    \t\t\t\tresult.push(key);\n    \t\t\t}\n    \t\t});\n    \t\treturn result.sort();\n    \t}\n\n    \t/**\n    \t * Checks if the specified object `property` exists and is a direct property,\n    \t * instead of an inherited property.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {Object} object The object to check.\n    \t * @param {string} property The property to check for.\n    \t * @returns {boolean} Returns `true` if key is a direct property, else `false`.\n    \t * @example\n    \t *\n    \t * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');\n    \t * // => true\n    \t */\n    \tfunction has(object, property) {\n    \t\treturn object ? hasOwnProperty.call(object, property) : false;\n    \t}\n\n    \t/**\n    \t * Creates an object composed of the inverted keys and values of the given object.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {Object} object The object to invert.\n    \t * @returns {Object} Returns the created inverted object.\n    \t * @example\n    \t *\n    \t *  _.invert({ 'first': 'moe', 'second': 'larry' });\n    \t * // => { 'moe': 'first', 'larry': 'second' }\n    \t */\n    \tfunction invert(object) {\n    \t\tvar index = -1,\n    \t\t\tprops = keys(object),\n    \t\t\tlength = props.length,\n    \t\t\tresult = {};\n\n    \t\twhile (++index < length) {\n    \t\t\tvar key = props[index];\n    \t\t\tresult[object[key]] = key;\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Checks if `value` is a boolean value.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.\n    \t * @example\n    \t *\n    \t * _.isBoolean(null);\n    \t * // => false\n    \t */\n    \tfunction isBoolean(value) {\n    \t\treturn value === true || value === false || toString.call(value) == boolClass;\n    \t}\n\n    \t/**\n    \t * Checks if `value` is a date.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is a date, else `false`.\n    \t * @example\n    \t *\n    \t * _.isDate(new Date);\n    \t * // => true\n    \t */\n    \tfunction isDate(value) {\n    \t\treturn value ? (typeof value == 'object' && toString.call(value) == dateClass) : false;\n    \t}\n\n    \t/**\n    \t * Checks if `value` is a DOM element.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.\n    \t * @example\n    \t *\n    \t * _.isElement(document.body);\n    \t * // => true\n    \t */\n    \tfunction isElement(value) {\n    \t\treturn value ? value.nodeType === 1 : false;\n    \t}\n\n    \t/**\n    \t * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a\n    \t * length of `0` and objects with no own enumerable properties are considered\n    \t * \"empty\".\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {Array|Object|string} value The value to inspect.\n    \t * @returns {boolean} Returns `true` if the `value` is empty, else `false`.\n    \t * @example\n    \t *\n    \t * _.isEmpty([1, 2, 3]);\n    \t * // => false\n    \t *\n    \t * _.isEmpty({});\n    \t * // => true\n    \t *\n    \t * _.isEmpty('');\n    \t * // => true\n    \t */\n    \tfunction isEmpty(value) {\n    \t\tif (!value) {\n    \t\t\treturn true;\n    \t\t}\n    \t\tif (isArray(value) || isString(value)) {\n    \t\t\treturn !value.length;\n    \t\t}\n    \t\tfor (var key in value) {\n    \t\t\tif (hasOwnProperty.call(value, key)) {\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t}\n    \t\treturn true;\n    \t}\n\n    \t/**\n    \t * Performs a deep comparison between two values to determine if they are\n    \t * equivalent to each other. If a callback is provided it will be executed\n    \t * to compare values. If the callback returns `undefined` comparisons will\n    \t * be handled by the method instead. The callback is bound to `thisArg` and\n    \t * invoked with two arguments; (a, b).\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} a The value to compare.\n    \t * @param {*} b The other value to compare.\n    \t * @param {Function} [callback] The function to customize comparing values.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n    \t * @example\n    \t *\n    \t * var moe = { 'name': 'moe', 'age': 40 };\n    \t * var copy = { 'name': 'moe', 'age': 40 };\n    \t *\n    \t * moe == copy;\n    \t * // => false\n    \t *\n    \t * _.isEqual(moe, copy);\n    \t * // => true\n    \t *\n    \t * var words = ['hello', 'goodbye'];\n    \t * var otherWords = ['hi', 'goodbye'];\n    \t *\n    \t * _.isEqual(words, otherWords, function(a, b) {\n       *   var reGreet = /^(?:hello|hi)$/i,\n       *       aGreet = _.isString(a) && reGreet.test(a),\n       *       bGreet = _.isString(b) && reGreet.test(b);\n       *\n       *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;\n       * });\n    \t * // => true\n    \t */\n    \tfunction isEqual(a, b) {\n    \t\treturn baseIsEqual(a, b);\n    \t}\n\n    \t/**\n    \t * Checks if `value` is, or can be coerced to, a finite number.\n    \t *\n    \t * Note: This is not the same as native `isFinite` which will return true for\n    \t * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is finite, else `false`.\n    \t * @example\n    \t *\n    \t * _.isFinite(-101);\n    \t * // => true\n    \t *\n    \t * _.isFinite('10');\n    \t * // => true\n    \t *\n    \t * _.isFinite(true);\n    \t * // => false\n    \t *\n    \t * _.isFinite('');\n    \t * // => false\n    \t *\n    \t * _.isFinite(Infinity);\n    \t * // => false\n    \t */\n    \tfunction isFinite(value) {\n    \t\treturn nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));\n    \t}\n\n    \t/**\n    \t * Checks if `value` is a function.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is a function, else `false`.\n    \t * @example\n    \t *\n    \t * _.isFunction(_);\n    \t * // => true\n    \t */\n    \tfunction isFunction(value) {\n    \t\treturn typeof value == 'function';\n    \t}\n    \t// fallback for older versions of Chrome and Safari\n    \tif (isFunction(/x/)) {\n    \t\tisFunction = function(value) {\n    \t\t\treturn typeof value == 'function' && toString.call(value) == funcClass;\n    \t\t};\n    \t}\n\n    \t/**\n    \t * Checks if `value` is the language type of Object.\n    \t * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is an object, else `false`.\n    \t * @example\n    \t *\n    \t * _.isObject({});\n    \t * // => true\n    \t *\n    \t * _.isObject([1, 2, 3]);\n    \t * // => true\n    \t *\n    \t * _.isObject(1);\n    \t * // => false\n    \t */\n    \tfunction isObject(value) {\n    \t\t// check if the value is the ECMAScript language type of Object\n    \t\t// http://es5.github.io/#x8\n    \t\t// and avoid a V8 bug\n    \t\t// http://code.google.com/p/v8/issues/detail?id=2291\n    \t\treturn !!(value && objectTypes[typeof value]);\n    \t}\n\n    \t/**\n    \t * Checks if `value` is `NaN`.\n    \t *\n    \t * Note: This is not the same as native `isNaN` which will return `true` for\n    \t * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.\n    \t * @example\n    \t *\n    \t * _.isNaN(NaN);\n    \t * // => true\n    \t *\n    \t * _.isNaN(new Number(NaN));\n    \t * // => true\n    \t *\n    \t * isNaN(undefined);\n    \t * // => true\n    \t *\n    \t * _.isNaN(undefined);\n    \t * // => false\n    \t */\n    \tfunction isNaN(value) {\n    \t\t// `NaN` as a primitive is the only value that is not equal to itself\n    \t\t// (perform the [[Class]] check first to avoid errors with some host objects in IE)\n    \t\treturn isNumber(value) && value != +value;\n    \t}\n\n    \t/**\n    \t * Checks if `value` is `null`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.\n    \t * @example\n    \t *\n    \t * _.isNull(null);\n    \t * // => true\n    \t *\n    \t * _.isNull(undefined);\n    \t * // => false\n    \t */\n    \tfunction isNull(value) {\n    \t\treturn value === null;\n    \t}\n\n    \t/**\n    \t * Checks if `value` is a number.\n    \t *\n    \t * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is a number, else `false`.\n    \t * @example\n    \t *\n    \t * _.isNumber(8.4 * 5);\n    \t * // => true\n    \t */\n    \tfunction isNumber(value) {\n    \t\treturn typeof value == 'number' || toString.call(value) == numberClass;\n    \t}\n\n    \t/**\n    \t * Checks if `value` is a regular expression.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.\n    \t * @example\n    \t *\n    \t * _.isRegExp(/moe/);\n    \t * // => true\n    \t */\n    \tfunction isRegExp(value) {\n    \t\treturn (value && objectTypes[typeof value]) ? toString.call(value) == regexpClass : false;\n    \t}\n\n    \t/**\n    \t * Checks if `value` is a string.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is a string, else `false`.\n    \t * @example\n    \t *\n    \t * _.isString('moe');\n    \t * // => true\n    \t */\n    \tfunction isString(value) {\n    \t\treturn typeof value == 'string' || toString.call(value) == stringClass;\n    \t}\n\n    \t/**\n    \t * Checks if `value` is `undefined`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {*} value The value to check.\n    \t * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.\n    \t * @example\n    \t *\n    \t * _.isUndefined(void 0);\n    \t * // => true\n    \t */\n    \tfunction isUndefined(value) {\n    \t\treturn typeof value == 'undefined';\n    \t}\n\n    \t/**\n    \t * Creates a shallow clone of `object` excluding the specified properties.\n    \t * Property names may be specified as individual arguments or as arrays of\n    \t * property names. If a callback is provided it will be executed for each\n    \t * property of `object` omitting the properties the callback returns truey\n    \t * for. The callback is bound to `thisArg` and invoked with three arguments;\n    \t * (value, key, object).\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {Object} object The source object.\n    \t * @param {Function|...string|string[]} [callback] The properties to omit or the\n    \t *  function called per iteration.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Object} Returns an object without the omitted properties.\n    \t * @example\n    \t *\n    \t * _.omit({ 'name': 'moe', 'age': 40 }, 'age');\n    \t * // => { 'name': 'moe' }\n    \t *\n    \t * _.omit({ 'name': 'moe', 'age': 40 }, function(value) {\n       *   return typeof value == 'number';\n       * });\n    \t * // => { 'name': 'moe' }\n    \t */\n    \tfunction omit(object) {\n    \t\tvar indexOf = getIndexOf(),\n    \t\t\tprops = baseFlatten(arguments, true, false, 1),\n    \t\t\tresult = {};\n\n    \t\tforIn(object, function(value, key) {\n    \t\t\tif (indexOf(props, key) < 0) {\n    \t\t\t\tresult[key] = value;\n    \t\t\t}\n    \t\t});\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Creates a two dimensional array of an object's key-value pairs,\n    \t * i.e. `[[key1, value1], [key2, value2]]`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {Object} object The object to inspect.\n    \t * @returns {Array} Returns new array of key-value pairs.\n    \t * @example\n    \t *\n    \t * _.pairs({ 'moe': 30, 'larry': 40 });\n    \t * // => [['moe', 30], ['larry', 40]] (property order is not guaranteed across environments)\n    \t */\n    \tfunction pairs(object) {\n    \t\tvar index = -1,\n    \t\t\tprops = keys(object),\n    \t\t\tlength = props.length,\n    \t\t\tresult = Array(length);\n\n    \t\twhile (++index < length) {\n    \t\t\tvar key = props[index];\n    \t\t\tresult[index] = [key, object[key]];\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Creates a shallow clone of `object` composed of the specified properties.\n    \t * Property names may be specified as individual arguments or as arrays of\n    \t * property names. If a callback is provided it will be executed for each\n    \t * property of `object` picking the properties the callback returns truey\n    \t * for. The callback is bound to `thisArg` and invoked with three arguments;\n    \t * (value, key, object).\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {Object} object The source object.\n    \t * @param {Function|...string|string[]} [callback] The function called per\n    \t *  iteration or property names to pick, specified as individual property\n    \t *  names or arrays of property names.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Object} Returns an object composed of the picked properties.\n    \t * @example\n    \t *\n    \t * _.pick({ 'name': 'moe', '_userid': 'moe1' }, 'name');\n    \t * // => { 'name': 'moe' }\n    \t *\n    \t * _.pick({ 'name': 'moe', '_userid': 'moe1' }, function(value, key) {\n       *   return key.charAt(0) != '_';\n       * });\n    \t * // => { 'name': 'moe' }\n    \t */\n    \tfunction pick(object) {\n    \t\tvar index = -1,\n    \t\t\tprops = baseFlatten(arguments, true, false, 1),\n    \t\t\tlength = props.length,\n    \t\t\tresult = {};\n\n    \t\twhile (++index < length) {\n    \t\t\tvar prop = props[index];\n    \t\t\tif (prop in object) {\n    \t\t\t\tresult[prop] = object[prop];\n    \t\t\t}\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Creates an array composed of the own enumerable property values of `object`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Objects\n    \t * @param {Object} object The object to inspect.\n    \t * @returns {Array} Returns an array of property values.\n    \t * @example\n    \t *\n    \t * _.values({ 'one': 1, 'two': 2, 'three': 3 });\n    \t * // => [1, 2, 3] (property order is not guaranteed across environments)\n    \t */\n    \tfunction values(object) {\n    \t\tvar index = -1,\n    \t\t\tprops = keys(object),\n    \t\t\tlength = props.length,\n    \t\t\tresult = Array(length);\n\n    \t\twhile (++index < length) {\n    \t\t\tresult[index] = object[props[index]];\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t/**\n    \t * Checks if a given value is present in a collection using strict equality\n    \t * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the\n    \t * offset from the end of the collection.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias include\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {*} target The value to check for.\n    \t * @param {number} [fromIndex=0] The index to search from.\n    \t * @returns {boolean} Returns `true` if the `target` element is found, else `false`.\n    \t * @example\n    \t *\n    \t * _.contains([1, 2, 3], 1);\n    \t * // => true\n    \t *\n    \t * _.contains([1, 2, 3], 1, 2);\n    \t * // => false\n    \t *\n    \t * _.contains({ 'name': 'moe', 'age': 40 }, 'moe');\n    \t * // => true\n    \t *\n    \t * _.contains('curly', 'ur');\n    \t * // => true\n    \t */\n    \tfunction contains(collection, target) {\n    \t\tvar indexOf = getIndexOf(),\n    \t\t\tlength = collection ? collection.length : 0,\n    \t\t\tresult = false;\n    \t\tif (length && typeof length == 'number') {\n    \t\t\tresult = indexOf(collection, target) > -1;\n    \t\t} else {\n    \t\t\tforOwn(collection, function(value) {\n    \t\t\t\treturn (result = value === target) && indicatorObject;\n    \t\t\t});\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Creates an object composed of keys generated from the results of running\n    \t * each element of `collection` through the callback. The corresponding value\n    \t * of each key is the number of times the key was returned by the callback.\n    \t * The callback is bound to `thisArg` and invoked with three arguments;\n    \t * (value, index|key, collection).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Object} Returns the composed aggregate object.\n    \t * @example\n    \t *\n    \t * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });\n    \t * // => { '4': 1, '6': 2 }\n    \t *\n    \t * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n    \t * // => { '4': 1, '6': 2 }\n    \t *\n    \t * _.countBy(['one', 'two', 'three'], 'length');\n    \t * // => { '3': 2, '5': 1 }\n    \t */\n    \tvar countBy = createAggregator(function(result, value, key) {\n    \t\t(hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);\n    \t});\n\n    \t/**\n    \t * Checks if the given callback returns truey value for **all** elements of\n    \t * a collection. The callback is bound to `thisArg` and invoked with three\n    \t * arguments; (value, index|key, collection).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias all\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {boolean} Returns `true` if all elements passed the callback check,\n    \t *  else `false`.\n    \t * @example\n    \t *\n    \t * _.every([true, 1, null, 'yes'], Boolean);\n    \t * // => false\n    \t *\n    \t * var stooges = [\n    \t *   { 'name': 'moe', 'age': 40 },\n    \t *   { 'name': 'larry', 'age': 50 }\n    \t * ];\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.every(stooges, 'age');\n    \t * // => true\n    \t *\n    \t * // using \"_.where\" callback shorthand\n    \t * _.every(stooges, { 'age': 50 });\n    \t * // => false\n    \t */\n    \tfunction every(collection, callback, thisArg) {\n    \t\tvar result = true;\n    \t\tcallback = createCallback(callback, thisArg, 3);\n\n    \t\tvar index = -1,\n    \t\t\tlength = collection ? collection.length : 0;\n\n    \t\tif (typeof length == 'number') {\n    \t\t\twhile (++index < length) {\n    \t\t\t\tif (!(result = !!callback(collection[index], index, collection))) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} else {\n    \t\t\tforOwn(collection, function(value, index, collection) {\n    \t\t\t\treturn !(result = !!callback(value, index, collection)) && indicatorObject;\n    \t\t\t});\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Iterates over elements of a collection, returning an array of all elements\n    \t * the callback returns truey for. The callback is bound to `thisArg` and\n    \t * invoked with three arguments; (value, index|key, collection).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias select\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Array} Returns a new array of elements that passed the callback check.\n    \t * @example\n    \t *\n    \t * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n    \t * // => [2, 4, 6]\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },\n    \t *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }\n    \t * ];\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.filter(food, 'organic');\n    \t * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]\n    \t *\n    \t * // using \"_.where\" callback shorthand\n    \t * _.filter(food, { 'type': 'fruit' });\n    \t * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]\n    \t */\n    \tfunction filter(collection, callback, thisArg) {\n    \t\tvar result = [];\n    \t\tcallback = createCallback(callback, thisArg, 3);\n\n    \t\tvar index = -1,\n    \t\t\tlength = collection ? collection.length : 0;\n\n    \t\tif (typeof length == 'number') {\n    \t\t\twhile (++index < length) {\n    \t\t\t\tvar value = collection[index];\n    \t\t\t\tif (callback(value, index, collection)) {\n    \t\t\t\t\tresult.push(value);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} else {\n    \t\t\tforOwn(collection, function(value, index, collection) {\n    \t\t\t\tif (callback(value, index, collection)) {\n    \t\t\t\t\tresult.push(value);\n    \t\t\t\t}\n    \t\t\t});\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Iterates over elements of a collection, returning the first element that\n    \t * the callback returns truey for. The callback is bound to `thisArg` and\n    \t * invoked with three arguments; (value, index|key, collection).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias detect, findWhere\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {*} Returns the found element, else `undefined`.\n    \t * @example\n    \t *\n    \t * _.find([1, 2, 3, 4], function(num) {\n       *   return num % 2 == 0;\n       * });\n    \t * // => 2\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },\n    \t *   { 'name': 'banana', 'organic': true,  'type': 'fruit' },\n    \t *   { 'name': 'beet',   'organic': false, 'type': 'vegetable' }\n    \t * ];\n    \t *\n    \t * // using \"_.where\" callback shorthand\n    \t * _.find(food, { 'type': 'vegetable' });\n    \t * // => { 'name': 'beet', 'organic': false, 'type': 'vegetable' }\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.find(food, 'organic');\n    \t * // => { 'name': 'banana', 'organic': true, 'type': 'fruit' }\n    \t */\n    \tfunction find(collection, callback, thisArg) {\n    \t\tcallback = createCallback(callback, thisArg, 3);\n\n    \t\tvar index = -1,\n    \t\t\tlength = collection ? collection.length : 0;\n\n    \t\tif (typeof length == 'number') {\n    \t\t\twhile (++index < length) {\n    \t\t\t\tvar value = collection[index];\n    \t\t\t\tif (callback(value, index, collection)) {\n    \t\t\t\t\treturn value;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} else {\n    \t\t\tvar result;\n    \t\t\tforOwn(collection, function(value, index, collection) {\n    \t\t\t\tif (callback(value, index, collection)) {\n    \t\t\t\t\tresult = value;\n    \t\t\t\t\treturn indicatorObject;\n    \t\t\t\t}\n    \t\t\t});\n    \t\t\treturn result;\n    \t\t}\n    \t}\n\n    \t/**\n    \t * Examines each element in a `collection`, returning the first that\n    \t * has the given properties. When checking `properties`, this method\n    \t * performs a deep comparison between values to determine if they are\n    \t * equivalent to each other.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Object} properties The object of property values to filter by.\n    \t * @returns {*} Returns the found element, else `undefined`.\n    \t * @example\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },\n    \t *   { 'name': 'banana', 'organic': true,  'type': 'fruit' },\n    \t *   { 'name': 'beet',   'organic': false, 'type': 'vegetable' }\n    \t * ];\n    \t *\n    \t * _.findWhere(food, { 'type': 'vegetable' });\n    \t * // => { 'name': 'beet', 'organic': false, 'type': 'vegetable' }\n    \t */\n    \tfunction findWhere(object, properties) {\n    \t\treturn where(object, properties, true);\n    \t}\n\n    \t/**\n    \t * Iterates over elements of a collection, executing the callback for each\n    \t * element. The callback is bound to `thisArg` and invoked with three arguments;\n    \t * (value, index|key, collection). Callbacks may exit iteration early by\n    \t * explicitly returning `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias each\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function} [callback=identity] The function called per iteration.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Array|Object|string} Returns `collection`.\n    \t * @example\n    \t *\n    \t * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');\n    \t * // => logs each number and returns '1,2,3'\n    \t *\n    \t * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });\n    \t * // => logs each number and returns the object (property order is not guaranteed across environments)\n    \t */\n    \tfunction forEach(collection, callback, thisArg) {\n    \t\tvar index = -1,\n    \t\t\tlength = collection ? collection.length : 0;\n\n    \t\tcallback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n    \t\tif (typeof length == 'number') {\n    \t\t\twhile (++index < length) {\n    \t\t\t\tif (callback(collection[index], index, collection) === indicatorObject) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} else {\n    \t\t\tforOwn(collection, callback);\n    \t\t}\n    \t}\n\n    \t/**\n    \t * This method is like `_.forEach` except that it iterates over elements\n    \t * of a `collection` from right to left.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias eachRight\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function} [callback=identity] The function called per iteration.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Array|Object|string} Returns `collection`.\n    \t * @example\n    \t *\n    \t * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');\n    \t * // => logs each number from right to left and returns '3,2,1'\n    \t */\n    \tfunction forEachRight(collection, callback) {\n    \t\tvar length = collection ? collection.length : 0;\n    \t\tif (typeof length == 'number') {\n    \t\t\twhile (length--) {\n    \t\t\t\tif (callback(collection[length], length, collection) === false) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} else {\n    \t\t\tvar props = keys(collection);\n    \t\t\tlength = props.length;\n    \t\t\tforOwn(collection, function(value, key, collection) {\n    \t\t\t\tkey = props ? props[--length] : --length;\n    \t\t\t\treturn callback(collection[key], key, collection) === false && indicatorObject;\n    \t\t\t});\n    \t\t}\n    \t}\n\n    \t/**\n    \t * Creates an object composed of keys generated from the results of running\n    \t * each element of a collection through the callback. The corresponding value\n    \t * of each key is an array of the elements responsible for generating the key.\n    \t * The callback is bound to `thisArg` and invoked with three arguments;\n    \t * (value, index|key, collection).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Object} Returns the composed aggregate object.\n    \t * @example\n    \t *\n    \t * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });\n    \t * // => { '4': [4.2], '6': [6.1, 6.4] }\n    \t *\n    \t * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n    \t * // => { '4': [4.2], '6': [6.1, 6.4] }\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.groupBy(['one', 'two', 'three'], 'length');\n    \t * // => { '3': ['one', 'two'], '5': ['three'] }\n    \t */\n    \tvar groupBy = createAggregator(function(result, value, key) {\n    \t\t(hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);\n    \t});\n\n    \t/**\n    \t * Creates an object composed of keys generated from the results of running\n    \t * each element of the collection through the given callback. The corresponding\n    \t * value of each key is the last element responsible for generating the key.\n    \t * The callback is bound to `thisArg` and invoked with three arguments;\n    \t * (value, index|key, collection).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Object} Returns the composed aggregate object.\n    \t * @example\n    \t *\n    \t * var keys = [\n    \t *   { 'dir': 'left', 'code': 97 },\n    \t *   { 'dir': 'right', 'code': 100 }\n    \t * ];\n    \t *\n    \t * _.indexBy(keys, 'dir');\n    \t * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n    \t *\n    \t * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });\n    \t * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n    \t *\n    \t * _.indexBy(stooges, function(key) { this.fromCharCode(key.code); }, String);\n    \t * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n    \t */\n    \tvar indexBy = createAggregator(function(result, value, key) {\n    \t\tresult[key] = value;\n    \t});\n\n    \t/**\n    \t * Invokes the method named by `methodName` on each element in the `collection`\n    \t * returning an array of the results of each invoked method. Additional arguments\n    \t * will be provided to each invoked method. If `methodName` is a function it\n    \t * will be invoked for, and `this` bound to, each element in the `collection`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|string} methodName The name of the method to invoke or\n    \t *  the function invoked per iteration.\n    \t * @param {...*} [arg] Arguments to invoke the method with.\n    \t * @returns {Array} Returns a new array of the results of each invoked method.\n    \t * @example\n    \t *\n    \t * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n    \t * // => [[1, 5, 7], [1, 2, 3]]\n    \t *\n    \t * _.invoke([123, 456], String.prototype.split, '');\n    \t * // => [['1', '2', '3'], ['4', '5', '6']]\n    \t */\n    \tfunction invoke(collection, methodName) {\n    \t\tvar args = nativeSlice.call(arguments, 2),\n    \t\t\tindex = -1,\n    \t\t\tisFunc = typeof methodName == 'function',\n    \t\t\tlength = collection ? collection.length : 0,\n    \t\t\tresult = Array(typeof length == 'number' ? length : 0);\n\n    \t\tforEach(collection, function(value) {\n    \t\t\tresult[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);\n    \t\t});\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Creates an array of values by running each element in the collection\n    \t * through the callback. The callback is bound to `thisArg` and invoked with\n    \t * three arguments; (value, index|key, collection).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias collect\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Array} Returns a new array of the results of each `callback` execution.\n    \t * @example\n    \t *\n    \t * _.map([1, 2, 3], function(num) { return num * 3; });\n    \t * // => [3, 6, 9]\n    \t *\n    \t * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });\n    \t * // => [3, 6, 9] (property order is not guaranteed across environments)\n    \t *\n    \t * var stooges = [\n    \t *   { 'name': 'moe', 'age': 40 },\n    \t *   { 'name': 'larry', 'age': 50 }\n    \t * ];\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.map(stooges, 'name');\n    \t * // => ['moe', 'larry']\n    \t */\n    \tfunction map(collection, callback, thisArg) {\n    \t\tvar index = -1,\n    \t\t\tlength = collection ? collection.length : 0;\n\n    \t\tcallback = createCallback(callback, thisArg, 3);\n    \t\tif (typeof length == 'number') {\n    \t\t\tvar result = Array(length);\n    \t\t\twhile (++index < length) {\n    \t\t\t\tresult[index] = callback(collection[index], index, collection);\n    \t\t\t}\n    \t\t} else {\n    \t\t\tresult = [];\n    \t\t\tforOwn(collection, function(value, key, collection) {\n    \t\t\t\tresult[++index] = callback(value, key, collection);\n    \t\t\t});\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Retrieves the maximum value of a collection. If the collection is empty or\n    \t * falsey `-Infinity` is returned. If a callback is provided it will be executed\n    \t * for each value in the collection to generate the criterion by which the value\n    \t * is ranked. The callback is bound to `thisArg` and invoked with three\n    \t * arguments; (value, index, collection).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {*} Returns the maximum value.\n    \t * @example\n    \t *\n    \t * _.max([4, 2, 8, 6]);\n    \t * // => 8\n    \t *\n    \t * var stooges = [\n    \t *   { 'name': 'moe', 'age': 40 },\n    \t *   { 'name': 'larry', 'age': 50 }\n    \t * ];\n    \t *\n    \t * _.max(stooges, function(stooge) { return stooge.age; });\n    \t * // => { 'name': 'larry', 'age': 50 };\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.max(stooges, 'age');\n    \t * // => { 'name': 'larry', 'age': 50 };\n    \t */\n    \tfunction max(collection, callback, thisArg) {\n    \t\tvar computed = -Infinity,\n    \t\t\tresult = computed;\n\n    \t\tvar index = -1,\n    \t\t\tlength = collection ? collection.length : 0;\n\n    \t\tif (!callback && typeof length == 'number') {\n    \t\t\twhile (++index < length) {\n    \t\t\t\tvar value = collection[index];\n    \t\t\t\tif (value > result) {\n    \t\t\t\t\tresult = value;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} else {\n    \t\t\tcallback = createCallback(callback, thisArg, 3);\n\n    \t\t\tforEach(collection, function(value, index, collection) {\n    \t\t\t\tvar current = callback(value, index, collection);\n    \t\t\t\tif (current > computed) {\n    \t\t\t\t\tcomputed = current;\n    \t\t\t\t\tresult = value;\n    \t\t\t\t}\n    \t\t\t});\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Retrieves the minimum value of a collection. If the collection is empty or\n    \t * falsey `Infinity` is returned. If a callback is provided it will be executed\n    \t * for each value in the collection to generate the criterion by which the value\n    \t * is ranked. The callback is bound to `thisArg` and invoked with three\n    \t * arguments; (value, index, collection).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {*} Returns the minimum value.\n    \t * @example\n    \t *\n    \t * _.min([4, 2, 8, 6]);\n    \t * // => 2\n    \t *\n    \t * var stooges = [\n    \t *   { 'name': 'moe', 'age': 40 },\n    \t *   { 'name': 'larry', 'age': 50 }\n    \t * ];\n    \t *\n    \t * _.min(stooges, function(stooge) { return stooge.age; });\n    \t * // => { 'name': 'moe', 'age': 40 };\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.min(stooges, 'age');\n    \t * // => { 'name': 'moe', 'age': 40 };\n    \t */\n    \tfunction min(collection, callback, thisArg) {\n    \t\tvar computed = Infinity,\n    \t\t\tresult = computed;\n\n    \t\tvar index = -1,\n    \t\t\tlength = collection ? collection.length : 0;\n\n    \t\tif (!callback && typeof length == 'number') {\n    \t\t\twhile (++index < length) {\n    \t\t\t\tvar value = collection[index];\n    \t\t\t\tif (value < result) {\n    \t\t\t\t\tresult = value;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} else {\n    \t\t\tcallback = createCallback(callback, thisArg, 3);\n\n    \t\t\tforEach(collection, function(value, index, collection) {\n    \t\t\t\tvar current = callback(value, index, collection);\n    \t\t\t\tif (current < computed) {\n    \t\t\t\t\tcomputed = current;\n    \t\t\t\t\tresult = value;\n    \t\t\t\t}\n    \t\t\t});\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Retrieves the value of a specified property from all elements in the `collection`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @type Function\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {string} property The property to pluck.\n    \t * @returns {Array} Returns a new array of property values.\n    \t * @example\n    \t *\n    \t * var stooges = [\n    \t *   { 'name': 'moe', 'age': 40 },\n    \t *   { 'name': 'larry', 'age': 50 }\n    \t * ];\n    \t *\n    \t * _.pluck(stooges, 'name');\n    \t * // => ['moe', 'larry']\n    \t */\n    \tfunction pluck(collection, property) {\n    \t\tvar index = -1,\n    \t\t\tlength = collection ? collection.length : 0;\n\n    \t\tif (typeof length == 'number') {\n    \t\t\tvar result = Array(length);\n    \t\t\twhile (++index < length) {\n    \t\t\t\tresult[index] = collection[index][property];\n    \t\t\t}\n    \t\t}\n    \t\treturn result || map(collection, property);\n    \t}\n\n    \t/**\n    \t * Reduces a collection to a value which is the accumulated result of running\n    \t * each element in the collection through the callback, where each successive\n    \t * callback execution consumes the return value of the previous execution. If\n    \t * `accumulator` is not provided the first element of the collection will be\n    \t * used as the initial `accumulator` value. The callback is bound to `thisArg`\n    \t * and invoked with four arguments; (accumulator, value, index|key, collection).\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias foldl, inject\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function} [callback=identity] The function called per iteration.\n    \t * @param {*} [accumulator] Initial value of the accumulator.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {*} Returns the accumulated value.\n    \t * @example\n    \t *\n    \t * var sum = _.reduce([1, 2, 3], function(sum, num) {\n       *   return sum + num;\n       * });\n    \t * // => 6\n    \t *\n    \t * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n       *   result[key] = num * 3;\n       *   return result;\n       * }, {});\n    \t * // => { 'a': 3, 'b': 6, 'c': 9 }\n    \t */\n    \tfunction reduce(collection, callback, accumulator, thisArg) {\n    \t\tif (!collection) return accumulator;\n    \t\tvar noaccum = arguments.length < 3;\n    \t\tcallback = baseCreateCallback(callback, thisArg, 4);\n\n    \t\tvar index = -1,\n    \t\t\tlength = collection.length;\n\n    \t\tif (typeof length == 'number') {\n    \t\t\tif (noaccum) {\n    \t\t\t\taccumulator = collection[++index];\n    \t\t\t}\n    \t\t\twhile (++index < length) {\n    \t\t\t\taccumulator = callback(accumulator, collection[index], index, collection);\n    \t\t\t}\n    \t\t} else {\n    \t\t\tforOwn(collection, function(value, index, collection) {\n    \t\t\t\taccumulator = noaccum\n    \t\t\t\t\t? (noaccum = false, value)\n    \t\t\t\t\t: callback(accumulator, value, index, collection)\n    \t\t\t});\n    \t\t}\n    \t\treturn accumulator;\n    \t}\n\n    \t/**\n    \t * This method is like `_.reduce` except that it iterates over elements\n    \t * of a `collection` from right to left.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias foldr\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function} [callback=identity] The function called per iteration.\n    \t * @param {*} [accumulator] Initial value of the accumulator.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {*} Returns the accumulated value.\n    \t * @example\n    \t *\n    \t * var list = [[0, 1], [2, 3], [4, 5]];\n    \t * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);\n    \t * // => [4, 5, 2, 3, 0, 1]\n    \t */\n    \tfunction reduceRight(collection, callback, accumulator, thisArg) {\n    \t\tvar noaccum = arguments.length < 3;\n    \t\tcallback = baseCreateCallback(callback, thisArg, 4);\n    \t\tforEachRight(collection, function(value, index, collection) {\n    \t\t\taccumulator = noaccum\n    \t\t\t\t? (noaccum = false, value)\n    \t\t\t\t: callback(accumulator, value, index, collection);\n    \t\t});\n    \t\treturn accumulator;\n    \t}\n\n    \t/**\n    \t * The opposite of `_.filter` this method returns the elements of a\n    \t * collection that the callback does **not** return truey for.\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Array} Returns a new array of elements that failed the callback check.\n    \t * @example\n    \t *\n    \t * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n    \t * // => [1, 3, 5]\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },\n    \t *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }\n    \t * ];\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.reject(food, 'organic');\n    \t * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]\n    \t *\n    \t * // using \"_.where\" callback shorthand\n    \t * _.reject(food, { 'type': 'fruit' });\n    \t * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]\n    \t */\n    \tfunction reject(collection, callback, thisArg) {\n    \t\tcallback = createCallback(callback, thisArg, 3);\n    \t\treturn filter(collection, function(value, index, collection) {\n    \t\t\treturn !callback(value, index, collection);\n    \t\t});\n    \t}\n\n    \t/**\n    \t * Retrieves a random element or `n` random elements from a collection.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to sample.\n    \t * @param {number} [n] The number of elements to sample.\n    \t * @param- {Object} [guard] Allows working with functions, like `_.map`,\n    \t *  without using their `key` and `object` arguments as sources.\n    \t * @returns {Array} Returns the random sample(s) of `collection`.\n    \t * @example\n    \t *\n    \t * _.sample([1, 2, 3, 4]);\n    \t * // => 2\n    \t *\n    \t * _.sample([1, 2, 3, 4], 2);\n    \t * // => [3, 1]\n    \t */\n    \tfunction sample(collection, n, guard) {\n    \t\tvar length = collection ? collection.length : 0;\n    \t\tif (typeof length != 'number') {\n    \t\t\tcollection = values(collection);\n    \t\t}\n    \t\tif (n == null || guard) {\n    \t\t\treturn collection ? collection[random(length - 1)] : undefined;\n    \t\t}\n    \t\tvar result = shuffle(collection);\n    \t\tresult.length = nativeMin(nativeMax(0, n), result.length);\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Creates an array of shuffled values, using a version of the Fisher-Yates\n    \t * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to shuffle.\n    \t * @returns {Array} Returns a new shuffled collection.\n    \t * @example\n    \t *\n    \t * _.shuffle([1, 2, 3, 4, 5, 6]);\n    \t * // => [4, 1, 6, 3, 5, 2]\n    \t */\n    \tfunction shuffle(collection) {\n    \t\tvar index = -1,\n    \t\t\tlength = collection ? collection.length : 0,\n    \t\t\tresult = Array(typeof length == 'number' ? length : 0);\n\n    \t\tforEach(collection, function(value) {\n    \t\t\tvar rand = random(++index);\n    \t\t\tresult[index] = result[rand];\n    \t\t\tresult[rand] = value;\n    \t\t});\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Gets the size of the `collection` by returning `collection.length` for arrays\n    \t * and array-like objects or the number of own enumerable properties for objects.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to inspect.\n    \t * @returns {number} Returns `collection.length` or number of own enumerable properties.\n    \t * @example\n    \t *\n    \t * _.size([1, 2]);\n    \t * // => 2\n    \t *\n    \t * _.size({ 'one': 1, 'two': 2, 'three': 3 });\n    \t * // => 3\n    \t *\n    \t * _.size('curly');\n    \t * // => 5\n    \t */\n    \tfunction size(collection) {\n    \t\tvar length = collection ? collection.length : 0;\n    \t\treturn typeof length == 'number' ? length : keys(collection).length;\n    \t}\n\n    \t/**\n    \t * Checks if the callback returns a truey value for **any** element of a\n    \t * collection. The function returns as soon as it finds a passing value and\n    \t * does not iterate over the entire collection. The callback is bound to\n    \t * `thisArg` and invoked with three arguments; (value, index|key, collection).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias any\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {boolean} Returns `true` if any element passed the callback check,\n    \t *  else `false`.\n    \t * @example\n    \t *\n    \t * _.some([null, 0, 'yes', false], Boolean);\n    \t * // => true\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },\n    \t *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }\n    \t * ];\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.some(food, 'organic');\n    \t * // => true\n    \t *\n    \t * // using \"_.where\" callback shorthand\n    \t * _.some(food, { 'type': 'meat' });\n    \t * // => false\n    \t */\n    \tfunction some(collection, callback, thisArg) {\n    \t\tvar result;\n    \t\tcallback = createCallback(callback, thisArg, 3);\n\n    \t\tvar index = -1,\n    \t\t\tlength = collection ? collection.length : 0;\n\n    \t\tif (typeof length == 'number') {\n    \t\t\twhile (++index < length) {\n    \t\t\t\tif ((result = callback(collection[index], index, collection))) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} else {\n    \t\t\tforOwn(collection, function(value, index, collection) {\n    \t\t\t\treturn (result = callback(value, index, collection)) && indicatorObject;\n    \t\t\t});\n    \t\t}\n    \t\treturn !!result;\n    \t}\n\n    \t/**\n    \t * Creates an array of elements, sorted in ascending order by the results of\n    \t * running each element in a collection through the callback. This method\n    \t * performs a stable sort, that is, it will preserve the original sort order\n    \t * of equal elements. The callback is bound to `thisArg` and invoked with\n    \t * three arguments; (value, index|key, collection).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Array} Returns a new array of sorted elements.\n    \t * @example\n    \t *\n    \t * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });\n    \t * // => [3, 1, 2]\n    \t *\n    \t * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);\n    \t * // => [3, 1, 2]\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.sortBy(['banana', 'strawberry', 'apple'], 'length');\n    \t * // => ['apple', 'banana', 'strawberry']\n    \t */\n    \tfunction sortBy(collection, callback, thisArg) {\n    \t\tvar index = -1,\n    \t\t\tlength = collection ? collection.length : 0,\n    \t\t\tresult = Array(typeof length == 'number' ? length : 0);\n\n    \t\tcallback = createCallback(callback, thisArg, 3);\n    \t\tforEach(collection, function(value, key, collection) {\n    \t\t\tresult[++index] = {\n    \t\t\t\t'criteria': callback(value, key, collection),\n    \t\t\t\t'index': index,\n    \t\t\t\t'value': value\n    \t\t\t};\n    \t\t});\n\n    \t\tlength = result.length;\n    \t\tresult.sort(compareAscending);\n    \t\twhile (length--) {\n    \t\t\tresult[length] = result[length].value;\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Converts the `collection` to an array.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to convert.\n    \t * @returns {Array} Returns the new converted array.\n    \t * @example\n    \t *\n    \t * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);\n    \t * // => [2, 3, 4]\n    \t */\n    \tfunction toArray(collection) {\n    \t\tif (isArray(collection)) {\n    \t\t\treturn nativeSlice.call(collection);\n    \t\t}\n    \t\tif (collection && typeof collection.length == 'number') {\n    \t\t\treturn map(collection);\n    \t\t}\n    \t\treturn values(collection);\n    \t}\n\n    \t/**\n    \t * Performs a deep comparison of each element in a `collection` to the given\n    \t * `properties` object, returning an array of all elements that have equivalent\n    \t * property values.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @type Function\n    \t * @category Collections\n    \t * @param {Array|Object|string} collection The collection to iterate over.\n    \t * @param {Object} properties The object of property values to filter by.\n    \t * @returns {Array} Returns a new array of elements that have the given properties.\n    \t * @example\n    \t *\n    \t * var stooges = [\n    \t *   { 'name': 'curly', 'age': 30, 'quotes': ['Oh, a wise guy, eh?', 'Poifect!'] },\n    \t *   { 'name': 'moe', 'age': 40, 'quotes': ['Spread out!', 'You knucklehead!'] }\n    \t * ];\n    \t *\n    \t * _.where(stooges, { 'age': 40 });\n    \t * // => [{ 'name': 'moe', 'age': 40, 'quotes': ['Spread out!', 'You knucklehead!'] }]\n    \t *\n    \t * _.where(stooges, { 'quotes': ['Poifect!'] });\n    \t * // => [{ 'name': 'curly', 'age': 30, 'quotes': ['Oh, a wise guy, eh?', 'Poifect!'] }]\n    \t */\n    \tfunction where(collection, properties, first) {\n    \t\treturn (first && isEmpty(properties))\n    \t\t\t? undefined\n    \t\t\t: (first ? find : filter)(collection, properties);\n    \t}\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t/**\n    \t * Creates an array with all falsey values removed. The values `false`, `null`,\n    \t * `0`, `\"\"`, `undefined`, and `NaN` are all falsey.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {Array} array The array to compact.\n    \t * @returns {Array} Returns a new array of filtered values.\n    \t * @example\n    \t *\n    \t * _.compact([0, 1, false, 2, '', 3]);\n    \t * // => [1, 2, 3]\n    \t */\n    \tfunction compact(array) {\n    \t\tvar index = -1,\n    \t\t\tlength = array ? array.length : 0,\n    \t\t\tresult = [];\n\n    \t\twhile (++index < length) {\n    \t\t\tvar value = array[index];\n    \t\t\tif (value) {\n    \t\t\t\tresult.push(value);\n    \t\t\t}\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Creates an array excluding all values of the provided arrays using strict\n    \t * equality for comparisons, i.e. `===`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {Array} array The array to process.\n    \t * @param {...Array} [array] The arrays of values to exclude.\n    \t * @returns {Array} Returns a new array of filtered values.\n    \t * @example\n    \t *\n    \t * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);\n    \t * // => [1, 3, 4]\n    \t */\n    \tfunction difference(array) {\n    \t\tvar index = -1,\n    \t\t\tindexOf = getIndexOf(),\n    \t\t\tlength = array.length,\n    \t\t\tflattened = baseFlatten(arguments, true, true, 1),\n    \t\t\tresult = [];\n\n    \t\twhile (++index < length) {\n    \t\t\tvar value = array[index];\n    \t\t\tif (indexOf(flattened, value) < 0) {\n    \t\t\t\tresult.push(value);\n    \t\t\t}\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Gets the first element or first `n` elements of an array. If a callback\n    \t * is provided elements at the beginning of the array are returned as long\n    \t * as the callback returns truey. The callback is bound to `thisArg` and\n    \t * invoked with three arguments; (value, index, array).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias head, take\n    \t * @category Arrays\n    \t * @param {Array} array The array to query.\n    \t * @param {Function|Object|number|string} [callback] The function called\n    \t *  per element or the number of elements to return. If a property name or\n    \t *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n    \t *  style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {*} Returns the first element(s) of `array`.\n    \t * @example\n    \t *\n    \t * _.first([1, 2, 3]);\n    \t * // => 1\n    \t *\n    \t * _.first([1, 2, 3], 2);\n    \t * // => [1, 2]\n    \t *\n    \t * _.first([1, 2, 3], function(num) {\n       *   return num < 3;\n       * });\n    \t * // => [1, 2]\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'banana', 'organic': true },\n    \t *   { 'name': 'beet',   'organic': false },\n    \t * ];\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.first(food, 'organic');\n    \t * // => [{ 'name': 'banana', 'organic': true }]\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'apple',  'type': 'fruit' },\n    \t *   { 'name': 'banana', 'type': 'fruit' },\n    \t *   { 'name': 'beet',   'type': 'vegetable' }\n    \t * ];\n    \t *\n    \t * // using \"_.where\" callback shorthand\n    \t * _.first(food, { 'type': 'fruit' });\n    \t * // => [{ 'name': 'apple', 'type': 'fruit' }, { 'name': 'banana', 'type': 'fruit' }]\n    \t */\n    \tfunction first(array, callback, thisArg) {\n    \t\tvar n = 0,\n    \t\t\tlength = array ? array.length : 0;\n\n    \t\tif (typeof callback != 'number' && callback != null) {\n    \t\t\tvar index = -1;\n    \t\t\tcallback = createCallback(callback, thisArg, 3);\n    \t\t\twhile (++index < length && callback(array[index], index, array)) {\n    \t\t\t\tn++;\n    \t\t\t}\n    \t\t} else {\n    \t\t\tn = callback;\n    \t\t\tif (n == null || thisArg) {\n    \t\t\t\treturn array ? array[0] : undefined;\n    \t\t\t}\n    \t\t}\n    \t\treturn nativeSlice.call(array, 0, nativeMin(nativeMax(0, n), length));\n    \t}\n\n    \t/**\n    \t * Flattens a nested array (the nesting can be to any depth). If `isShallow`\n    \t * is truey, the array will only be flattened a single level. If a callback\n    \t * is provided each element of the array is passed through the callback before\n    \t * flattening. The callback is bound to `thisArg` and invoked with three\n    \t * arguments; (value, index, array).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {Array} array The array to flatten.\n    \t * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Array} Returns a new flattened array.\n    \t * @example\n    \t *\n    \t * _.flatten([1, [2], [3, [[4]]]]);\n    \t * // => [1, 2, 3, 4];\n    \t *\n    \t * _.flatten([1, [2], [3, [[4]]]], true);\n    \t * // => [1, 2, 3, [[4]]];\n    \t *\n    \t * var stooges = [\n    \t *   { 'name': 'curly', 'quotes': ['Oh, a wise guy, eh?', 'Poifect!'] },\n    \t *   { 'name': 'moe', 'quotes': ['Spread out!', 'You knucklehead!'] }\n    \t * ];\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.flatten(stooges, 'quotes');\n    \t * // => ['Oh, a wise guy, eh?', 'Poifect!', 'Spread out!', 'You knucklehead!']\n    \t */\n    \tfunction flatten(array, isShallow) {\n    \t\treturn baseFlatten(array, isShallow);\n    \t}\n\n    \t/**\n    \t * Gets the index at which the first occurrence of `value` is found using\n    \t * strict equality for comparisons, i.e. `===`. If the array is already sorted\n    \t * providing `true` for `fromIndex` will run a faster binary search.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {Array} array The array to search.\n    \t * @param {*} value The value to search for.\n    \t * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n    \t *  to perform a binary search on a sorted array.\n    \t * @returns {number} Returns the index of the matched value or `-1`.\n    \t * @example\n    \t *\n    \t * _.indexOf([1, 2, 3, 1, 2, 3], 2);\n    \t * // => 1\n    \t *\n    \t * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);\n    \t * // => 4\n    \t *\n    \t * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);\n    \t * // => 2\n    \t */\n    \tfunction indexOf(array, value, fromIndex) {\n    \t\tif (typeof fromIndex == 'number') {\n    \t\t\tvar length = array ? array.length : 0;\n    \t\t\tfromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);\n    \t\t} else if (fromIndex) {\n    \t\t\tvar index = sortedIndex(array, value);\n    \t\t\treturn array[index] === value ? index : -1;\n    \t\t}\n    \t\treturn baseIndexOf(array, value, fromIndex);\n    \t}\n\n    \t/**\n    \t * Gets all but the last element or last `n` elements of an array. If a\n    \t * callback is provided elements at the end of the array are excluded from\n    \t * the result as long as the callback returns truey. The callback is bound\n    \t * to `thisArg` and invoked with three arguments; (value, index, array).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {Array} array The array to query.\n    \t * @param {Function|Object|number|string} [callback=1] The function called\n    \t *  per element or the number of elements to exclude. If a property name or\n    \t *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n    \t *  style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Array} Returns a slice of `array`.\n    \t * @example\n    \t *\n    \t * _.initial([1, 2, 3]);\n    \t * // => [1, 2]\n    \t *\n    \t * _.initial([1, 2, 3], 2);\n    \t * // => [1]\n    \t *\n    \t * _.initial([1, 2, 3], function(num) {\n       *   return num > 1;\n       * });\n    \t * // => [1]\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'beet',   'organic': false },\n    \t *   { 'name': 'carrot', 'organic': true }\n    \t * ];\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.initial(food, 'organic');\n    \t * // => [{ 'name': 'beet',   'organic': false }]\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'banana', 'type': 'fruit' },\n    \t *   { 'name': 'beet',   'type': 'vegetable' },\n    \t *   { 'name': 'carrot', 'type': 'vegetable' }\n    \t * ];\n    \t *\n    \t * // using \"_.where\" callback shorthand\n    \t * _.initial(food, { 'type': 'vegetable' });\n    \t * // => [{ 'name': 'banana', 'type': 'fruit' }]\n    \t */\n    \tfunction initial(array, callback, thisArg) {\n    \t\tvar n = 0,\n    \t\t\tlength = array ? array.length : 0;\n\n    \t\tif (typeof callback != 'number' && callback != null) {\n    \t\t\tvar index = length;\n    \t\t\tcallback = createCallback(callback, thisArg, 3);\n    \t\t\twhile (index-- && callback(array[index], index, array)) {\n    \t\t\t\tn++;\n    \t\t\t}\n    \t\t} else {\n    \t\t\tn = (callback == null || thisArg) ? 1 : callback || n;\n    \t\t}\n    \t\treturn nativeSlice.call(array, 0, nativeMin(nativeMax(0, length - n), length));\n    \t}\n\n    \t/**\n    \t * Creates an array of unique values present in all provided arrays using\n    \t * strict equality for comparisons, i.e. `===`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {...Array} [array] The arrays to inspect.\n    \t * @returns {Array} Returns an array of composite values.\n    \t * @example\n    \t *\n    \t * _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);\n    \t * // => [1, 2]\n    \t */\n    \tfunction intersection(array) {\n    \t\tvar args = arguments,\n    \t\t\targsLength = args.length,\n    \t\t\tindex = -1,\n    \t\t\tindexOf = getIndexOf(),\n    \t\t\tlength = array ? array.length : 0,\n    \t\t\tresult = [];\n\n    \t\touter:\n    \t\t\twhile (++index < length) {\n    \t\t\t\tvar value = array[index];\n    \t\t\t\tif (indexOf(result, value) < 0) {\n    \t\t\t\t\tvar argsIndex = argsLength;\n    \t\t\t\t\twhile (--argsIndex) {\n    \t\t\t\t\t\tif (indexOf(args[argsIndex], value) < 0) {\n    \t\t\t\t\t\t\tcontinue outer;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\tresult.push(value);\n    \t\t\t\t}\n    \t\t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Gets the last element or last `n` elements of an array. If a callback is\n    \t * provided elements at the end of the array are returned as long as the\n    \t * callback returns truey. The callback is bound to `thisArg` and invoked\n    \t * with three arguments; (value, index, array).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {Array} array The array to query.\n    \t * @param {Function|Object|number|string} [callback] The function called\n    \t *  per element or the number of elements to return. If a property name or\n    \t *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n    \t *  style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {*} Returns the last element(s) of `array`.\n    \t * @example\n    \t *\n    \t * _.last([1, 2, 3]);\n    \t * // => 3\n    \t *\n    \t * _.last([1, 2, 3], 2);\n    \t * // => [2, 3]\n    \t *\n    \t * _.last([1, 2, 3], function(num) {\n       *   return num > 1;\n       * });\n    \t * // => [2, 3]\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'beet',   'organic': false },\n    \t *   { 'name': 'carrot', 'organic': true }\n    \t * ];\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.last(food, 'organic');\n    \t * // => [{ 'name': 'carrot', 'organic': true }]\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'banana', 'type': 'fruit' },\n    \t *   { 'name': 'beet',   'type': 'vegetable' },\n    \t *   { 'name': 'carrot', 'type': 'vegetable' }\n    \t * ];\n    \t *\n    \t * // using \"_.where\" callback shorthand\n    \t * _.last(food, { 'type': 'vegetable' });\n    \t * // => [{ 'name': 'beet', 'type': 'vegetable' }, { 'name': 'carrot', 'type': 'vegetable' }]\n    \t */\n    \tfunction last(array, callback, thisArg) {\n    \t\tvar n = 0,\n    \t\t\tlength = array ? array.length : 0;\n\n    \t\tif (typeof callback != 'number' && callback != null) {\n    \t\t\tvar index = length;\n    \t\t\tcallback = createCallback(callback, thisArg, 3);\n    \t\t\twhile (index-- && callback(array[index], index, array)) {\n    \t\t\t\tn++;\n    \t\t\t}\n    \t\t} else {\n    \t\t\tn = callback;\n    \t\t\tif (n == null || thisArg) {\n    \t\t\t\treturn array ? array[length - 1] : undefined;\n    \t\t\t}\n    \t\t}\n    \t\treturn nativeSlice.call(array, nativeMax(0, length - n));\n    \t}\n\n    \t/**\n    \t * Gets the index at which the last occurrence of `value` is found using strict\n    \t * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used\n    \t * as the offset from the end of the collection.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {Array} array The array to search.\n    \t * @param {*} value The value to search for.\n    \t * @param {number} [fromIndex=array.length-1] The index to search from.\n    \t * @returns {number} Returns the index of the matched value or `-1`.\n    \t * @example\n    \t *\n    \t * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n    \t * // => 4\n    \t *\n    \t * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);\n    \t * // => 1\n    \t */\n    \tfunction lastIndexOf(array, value, fromIndex) {\n    \t\tvar index = array ? array.length : 0;\n    \t\tif (typeof fromIndex == 'number') {\n    \t\t\tindex = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;\n    \t\t}\n    \t\twhile (index--) {\n    \t\t\tif (array[index] === value) {\n    \t\t\t\treturn index;\n    \t\t\t}\n    \t\t}\n    \t\treturn -1;\n    \t}\n\n    \t/**\n    \t * Creates an array of numbers (positive and/or negative) progressing from\n    \t * `start` up to but not including `end`. If `start` is less than `stop` a\n    \t * zero-length range is created unless a negative `step` is specified.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {number} [start=0] The start of the range.\n    \t * @param {number} end The end of the range.\n    \t * @param {number} [step=1] The value to increment or decrement by.\n    \t * @returns {Array} Returns a new range array.\n    \t * @example\n    \t *\n    \t * _.range(10);\n    \t * // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    \t *\n    \t * _.range(1, 11);\n    \t * // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \t *\n    \t * _.range(0, 30, 5);\n    \t * // => [0, 5, 10, 15, 20, 25]\n    \t *\n    \t * _.range(0, -10, -1);\n    \t * // => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n    \t *\n    \t * _.range(1, 4, 0);\n    \t * // => [1, 1, 1]\n    \t *\n    \t * _.range(0);\n    \t * // => []\n    \t */\n    \tfunction range(start, end, step) {\n    \t\tstart = +start || 0;\n    \t\tstep =  (+step || 1);\n\n    \t\tif (end == null) {\n    \t\t\tend = start;\n    \t\t\tstart = 0;\n    \t\t}\n    \t\t// use `Array(length)` so engines, like Chakra and V8, avoid slower modes\n    \t\t// http://youtu.be/XAqIpGU8ZZk#t=17m25s\n    \t\tvar index = -1,\n    \t\t\tlength = nativeMax(0, ceil((end - start) / step)),\n    \t\t\tresult = Array(length);\n\n    \t\twhile (++index < length) {\n    \t\t\tresult[index] = start;\n    \t\t\tstart += step;\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * The opposite of `_.initial` this method gets all but the first element or\n    \t * first `n` elements of an array. If a callback function is provided elements\n    \t * at the beginning of the array are excluded from the result as long as the\n    \t * callback returns truey. The callback is bound to `thisArg` and invoked\n    \t * with three arguments; (value, index, array).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias drop, tail\n    \t * @category Arrays\n    \t * @param {Array} array The array to query.\n    \t * @param {Function|Object|number|string} [callback=1] The function called\n    \t *  per element or the number of elements to exclude. If a property name or\n    \t *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n    \t *  style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Array} Returns a slice of `array`.\n    \t * @example\n    \t *\n    \t * _.rest([1, 2, 3]);\n    \t * // => [2, 3]\n    \t *\n    \t * _.rest([1, 2, 3], 2);\n    \t * // => [3]\n    \t *\n    \t * _.rest([1, 2, 3], function(num) {\n       *   return num < 3;\n       * });\n    \t * // => [3]\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'banana', 'organic': true },\n    \t *   { 'name': 'beet',   'organic': false },\n    \t * ];\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.rest(food, 'organic');\n    \t * // => [{ 'name': 'beet', 'organic': false }]\n    \t *\n    \t * var food = [\n    \t *   { 'name': 'apple',  'type': 'fruit' },\n    \t *   { 'name': 'banana', 'type': 'fruit' },\n    \t *   { 'name': 'beet',   'type': 'vegetable' }\n    \t * ];\n    \t *\n    \t * // using \"_.where\" callback shorthand\n    \t * _.rest(food, { 'type': 'fruit' });\n    \t * // => [{ 'name': 'beet', 'type': 'vegetable' }]\n    \t */\n    \tfunction rest(array, callback, thisArg) {\n    \t\tif (typeof callback != 'number' && callback != null) {\n    \t\t\tvar n = 0,\n    \t\t\t\tindex = -1,\n    \t\t\t\tlength = array ? array.length : 0;\n\n    \t\t\tcallback = createCallback(callback, thisArg, 3);\n    \t\t\twhile (++index < length && callback(array[index], index, array)) {\n    \t\t\t\tn++;\n    \t\t\t}\n    \t\t} else {\n    \t\t\tn = (callback == null || thisArg) ? 1 : nativeMax(0, callback);\n    \t\t}\n    \t\treturn nativeSlice.call(array, n);\n    \t}\n\n    \t/**\n    \t * Uses a binary search to determine the smallest index at which a value\n    \t * should be inserted into a given sorted array in order to maintain the sort\n    \t * order of the array. If a callback is provided it will be executed for\n    \t * `value` and each element of `array` to compute their sort ranking. The\n    \t * callback is bound to `thisArg` and invoked with one argument; (value).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {Array} array The array to inspect.\n    \t * @param {*} value The value to evaluate.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {number} Returns the index at which `value` should be inserted\n    \t *  into `array`.\n    \t * @example\n    \t *\n    \t * _.sortedIndex([20, 30, 50], 40);\n    \t * // => 2\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n    \t * // => 2\n    \t *\n    \t * var dict = {\n       *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }\n       * };\n    \t *\n    \t * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n       *   return dict.wordToNumber[word];\n       * });\n    \t * // => 2\n    \t *\n    \t * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n       *   return this.wordToNumber[word];\n       * }, dict);\n    \t * // => 2\n    \t */\n    \tfunction sortedIndex(array, value, callback, thisArg) {\n    \t\tvar low = 0,\n    \t\t\thigh = array ? array.length : low;\n\n    \t\t// explicitly reference `identity` for better inlining in Firefox\n    \t\tcallback = callback ? createCallback(callback, thisArg, 1) : identity;\n    \t\tvalue = callback(value);\n\n    \t\twhile (low < high) {\n    \t\t\tvar mid = (low + high) >>> 1;\n    \t\t\t(callback(array[mid]) < value)\n    \t\t\t\t? low = mid + 1\n    \t\t\t\t: high = mid;\n    \t\t}\n    \t\treturn low;\n    \t}\n\n    \t/**\n    \t * Creates an array of unique values, in order, of the provided arrays using\n    \t * strict equality for comparisons, i.e. `===`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {...Array} [array] The arrays to inspect.\n    \t * @returns {Array} Returns an array of composite values.\n    \t * @example\n    \t *\n    \t * _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);\n    \t * // => [1, 2, 3, 101, 10]\n    \t */\n    \tfunction union(array) {\n    \t\treturn baseUniq(baseFlatten(arguments, true, true));\n    \t}\n\n    \t/**\n    \t * Creates a duplicate-value-free version of an array using strict equality\n    \t * for comparisons, i.e. `===`. If the array is sorted, providing\n    \t * `true` for `isSorted` will use a faster algorithm. If a callback is provided\n    \t * each element of `array` is passed through the callback before uniqueness\n    \t * is computed. The callback is bound to `thisArg` and invoked with three\n    \t * arguments; (value, index, array).\n    \t *\n    \t * If a property name is provided for `callback` the created \"_.pluck\" style\n    \t * callback will return the property value of the given element.\n    \t *\n    \t * If an object is provided for `callback` the created \"_.where\" style callback\n    \t * will return `true` for elements that have the properties of the given object,\n    \t * else `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias unique\n    \t * @category Arrays\n    \t * @param {Array} array The array to process.\n    \t * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n    \t * @param {Function|Object|string} [callback=identity] The function called\n    \t *  per iteration. If a property name or object is provided it will be used\n    \t *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Array} Returns a duplicate-value-free array.\n    \t * @example\n    \t *\n    \t * _.uniq([1, 2, 1, 3, 1]);\n    \t * // => [1, 2, 3]\n    \t *\n    \t * _.uniq([1, 1, 2, 2, 3], true);\n    \t * // => [1, 2, 3]\n    \t *\n    \t * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });\n    \t * // => ['A', 'b', 'C']\n    \t *\n    \t * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);\n    \t * // => [1, 2.5, 3]\n    \t *\n    \t * // using \"_.pluck\" callback shorthand\n    \t * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n    \t * // => [{ 'x': 1 }, { 'x': 2 }]\n    \t */\n    \tfunction uniq(array, isSorted, callback, thisArg) {\n    \t\t// juggle arguments\n    \t\tif (typeof isSorted != 'boolean' && isSorted != null) {\n    \t\t\tthisArg = callback;\n    \t\t\tcallback = !(thisArg && thisArg[isSorted] === array) ? isSorted : null;\n    \t\t\tisSorted = false;\n    \t\t}\n    \t\tif (callback != null) {\n    \t\t\tcallback = createCallback(callback, thisArg, 3);\n    \t\t}\n    \t\treturn baseUniq(array, isSorted, callback);\n    \t}\n\n    \t/**\n    \t * Creates an array excluding all provided values using strict equality for\n    \t * comparisons, i.e. `===`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Arrays\n    \t * @param {Array} array The array to filter.\n    \t * @param {...*} [value] The values to exclude.\n    \t * @returns {Array} Returns a new array of filtered values.\n    \t * @example\n    \t *\n    \t * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n    \t * // => [2, 3, 4]\n    \t */\n    \tfunction without(array) {\n    \t\treturn difference(array, nativeSlice.call(arguments, 1));\n    \t}\n\n    \t/**\n    \t * Creates an array of grouped elements, the first of which contains the first\n    \t * elements of the given arrays, the second of which contains the second\n    \t * elements of the given arrays, and so on.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias unzip\n    \t * @category Arrays\n    \t * @param {...Array} [array] Arrays to process.\n    \t * @returns {Array} Returns a new array of grouped elements.\n    \t * @example\n    \t *\n    \t * _.zip(['moe', 'larry'], [30, 40], [true, false]);\n    \t * // => [['moe', 30, true], ['larry', 40, false]]\n    \t */\n    \tfunction zip() {\n    \t\tvar index = -1,\n    \t\t\tlength = max(pluck(arguments, 'length')),\n    \t\t\tresult = Array(length < 0 ? 0 : length);\n\n    \t\twhile (++index < length) {\n    \t\t\tresult[index] = pluck(arguments, index);\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Creates an object composed from arrays of `keys` and `values`. Provide\n    \t * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`\n    \t * or two arrays, one of `keys` and one of corresponding `values`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @alias object\n    \t * @category Arrays\n    \t * @param {Array} keys The array of keys.\n    \t * @param {Array} [values=[]] The array of values.\n    \t * @returns {Object} Returns an object composed of the given keys and\n    \t *  corresponding values.\n    \t * @example\n    \t *\n    \t * _.zipObject(['moe', 'larry'], [30, 40]);\n    \t * // => { 'moe': 30, 'larry': 40 }\n    \t */\n    \tfunction zipObject(keys, values) {\n    \t\tvar index = -1,\n    \t\t\tlength = keys ? keys.length : 0,\n    \t\t\tresult = {};\n\n    \t\twhile (++index < length) {\n    \t\t\tvar key = keys[index];\n    \t\t\tif (values) {\n    \t\t\t\tresult[key] = values[index];\n    \t\t\t} else if (key) {\n    \t\t\t\tresult[key[0]] = key[1];\n    \t\t\t}\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t/**\n    \t * Creates a function that executes `func`, with  the `this` binding and\n    \t * arguments of the created function, only after being called `n` times.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {number} n The number of times the function must be called before\n    \t *  `func` is executed.\n    \t * @param {Function} func The function to restrict.\n    \t * @returns {Function} Returns the new restricted function.\n    \t * @example\n    \t *\n    \t * var saves = ['profile', 'settings'];\n    \t *\n    \t * var done = _.after(saves.length, function() {\n       *   console.log('Done saving!');\n       * });\n    \t *\n    \t * _.forEach(saves, function(type) {\n       *   asyncSave({ 'type': type, 'complete': done });\n       * });\n    \t * // => logs 'Done saving!', after all saves have completed\n    \t */\n    \tfunction after(n, func) {\n    \t\tif (!isFunction(func)) {\n    \t\t\tthrow new TypeError;\n    \t\t}\n    \t\treturn function() {\n    \t\t\tif (--n < 1) {\n    \t\t\t\treturn func.apply(this, arguments);\n    \t\t\t}\n    \t\t};\n    \t}\n\n    \t/**\n    \t * Creates a function that, when called, invokes `func` with the `this`\n    \t * binding of `thisArg` and prepends any additional `bind` arguments to those\n    \t * provided to the bound function.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {Function} func The function to bind.\n    \t * @param {*} [thisArg] The `this` binding of `func`.\n    \t * @param {...*} [arg] Arguments to be partially applied.\n    \t * @returns {Function} Returns the new bound function.\n    \t * @example\n    \t *\n    \t * var func = function(greeting) {\n       *   return greeting + ' ' + this.name;\n       * };\n    \t *\n    \t * func = _.bind(func, { 'name': 'moe' }, 'hi');\n    \t * func();\n    \t * // => 'hi moe'\n    \t */\n    \tfunction bind(func, thisArg) {\n    \t\treturn arguments.length > 2\n    \t\t\t? createBound(func, 17, nativeSlice.call(arguments, 2), null, thisArg)\n    \t\t\t: createBound(func, 1, null, null, thisArg);\n    \t}\n\n    \t/**\n    \t * Binds methods of an object to the object itself, overwriting the existing\n    \t * method. Method names may be specified as individual arguments or as arrays\n    \t * of method names. If no method names are provided all the function properties\n    \t * of `object` will be bound.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {Object} object The object to bind and assign the bound methods to.\n    \t * @param {...string} [methodName] The object method names to\n    \t *  bind, specified as individual method names or arrays of method names.\n    \t * @returns {Object} Returns `object`.\n    \t * @example\n    \t *\n    \t * var view = {\n       *  'label': 'docs',\n       *  'onClick': function() { console.log('clicked ' + this.label); }\n       * };\n    \t *\n    \t * _.bindAll(view);\n    \t * jQuery('#docs').on('click', view.onClick);\n    \t * // => logs 'clicked docs', when the button is clicked\n    \t */\n    \tfunction bindAll(object) {\n    \t\tvar funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),\n    \t\t\tindex = -1,\n    \t\t\tlength = funcs.length;\n\n    \t\twhile (++index < length) {\n    \t\t\tvar key = funcs[index];\n    \t\t\tobject[key] = createBound(object[key], 1, null, null, object);\n    \t\t}\n    \t\treturn object;\n    \t}\n\n    \t/**\n    \t * Creates a function that is the composition of the provided functions,\n    \t * where each function consumes the return value of the function that follows.\n    \t * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.\n    \t * Each function is executed with the `this` binding of the composed function.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {...Function} [func] Functions to compose.\n    \t * @returns {Function} Returns the new composed function.\n    \t * @example\n    \t *\n    \t * var realNameMap = {\n       *   'curly': 'jerome'\n       * };\n    \t *\n    \t * var format = function(name) {\n       *   name = realNameMap[name.toLowerCase()] || name;\n       *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();\n       * };\n    \t *\n    \t * var greet = function(formatted) {\n       *   return 'Hiya ' + formatted + '!';\n       * };\n    \t *\n    \t * var welcome = _.compose(greet, format);\n    \t * welcome('curly');\n    \t * // => 'Hiya Jerome!'\n    \t */\n    \tfunction compose() {\n    \t\tvar funcs = arguments,\n    \t\t\tlength = funcs.length;\n\n    \t\twhile (length--) {\n    \t\t\tif (!isFunction(funcs[length])) {\n    \t\t\t\tthrow new TypeError;\n    \t\t\t}\n    \t\t}\n    \t\treturn function() {\n    \t\t\tvar args = arguments,\n    \t\t\t\tlength = funcs.length;\n\n    \t\t\twhile (length--) {\n    \t\t\t\targs = [funcs[length].apply(this, args)];\n    \t\t\t}\n    \t\t\treturn args[0];\n    \t\t};\n    \t}\n\n    \t/**\n    \t * Produces a callback bound to an optional `thisArg`. If `func` is a property\n    \t * name the created callback will return the property value for a given element.\n    \t * If `func` is an object the created callback will return `true` for elements\n    \t * that contain the equivalent object properties, otherwise it will return `false`.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {*} [func=identity] The value to convert to a callback.\n    \t * @param {*} [thisArg] The `this` binding of the created callback.\n    \t * @param {number} [argCount] The number of arguments the callback accepts.\n    \t * @returns {Function} Returns a callback function.\n    \t * @example\n    \t *\n    \t * var stooges = [\n    \t *   { 'name': 'moe', 'age': 40 },\n    \t *   { 'name': 'larry', 'age': 50 }\n    \t * ];\n    \t *\n    \t * // wrap to create custom callback shorthands\n    \t * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {\n       *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);\n       *   return !match ? func(callback, thisArg) : function(object) {\n       *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];\n       *   };\n       * });\n    \t *\n    \t * _.filter(stooges, 'age__gt45');\n    \t * // => [{ 'name': 'larry', 'age': 50 }]\n    \t */\n    \tfunction createCallback(func, thisArg, argCount) {\n    \t\tvar type = typeof func;\n    \t\tif (func == null || type == 'function') {\n    \t\t\treturn baseCreateCallback(func, thisArg, argCount);\n    \t\t}\n    \t\t// handle \"_.pluck\" style callback shorthands\n    \t\tif (type != 'object') {\n    \t\t\treturn function(object) {\n    \t\t\t\treturn object[func];\n    \t\t\t};\n    \t\t}\n    \t\tvar props = keys(func);\n    \t\treturn function(object) {\n    \t\t\tvar length = props.length,\n    \t\t\t\tresult = false;\n\n    \t\t\twhile (length--) {\n    \t\t\t\tif (!(result = object[props[length]] === func[props[length]])) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn result;\n    \t\t};\n    \t}\n\n    \t/**\n    \t * Creates a function that will delay the execution of `func` until after\n    \t * `wait` milliseconds have elapsed since the last time it was invoked.\n    \t * Provide an options object to indicate that `func` should be invoked on\n    \t * the leading and/or trailing edge of the `wait` timeout. Subsequent calls\n    \t * to the debounced function will return the result of the last `func` call.\n    \t *\n    \t * Note: If `leading` and `trailing` options are `true` `func` will be called\n    \t * on the trailing edge of the timeout only if the the debounced function is\n    \t * invoked more than once during the `wait` timeout.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {Function} func The function to debounce.\n    \t * @param {number} wait The number of milliseconds to delay.\n    \t * @param {Object} [options] The options object.\n    \t * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.\n    \t * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.\n    \t * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n    \t * @returns {Function} Returns the new debounced function.\n    \t * @example\n    \t *\n    \t * // avoid costly calculations while the window size is in flux\n    \t * var lazyLayout = _.debounce(calculateLayout, 150);\n    \t * jQuery(window).on('resize', lazyLayout);\n    \t *\n    \t * // execute `sendMail` when the click event is fired, debouncing subsequent calls\n    \t * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n       *   'leading': true,\n       *   'trailing': false\n       * });\n    \t *\n    \t * // ensure `batchLog` is executed once after 1 second of debounced calls\n    \t * var source = new EventSource('/stream');\n    \t * source.addEventListener('message', _.debounce(batchLog, 250, {\n       *   'maxWait': 1000\n       * }, false);\n    \t */\n    \tfunction debounce(func, wait, options) {\n    \t\tvar args,\n    \t\t\tmaxTimeoutId,\n    \t\t\tresult,\n    \t\t\tstamp,\n    \t\t\tthisArg,\n    \t\t\ttimeoutId,\n    \t\t\ttrailingCall,\n    \t\t\tlastCalled = 0,\n    \t\t\tmaxWait = false,\n    \t\t\ttrailing = true;\n\n    \t\tif (!isFunction(func)) {\n    \t\t\tthrow new TypeError;\n    \t\t}\n    \t\twait = nativeMax(0, wait) || 0;\n    \t\tif (options === true) {\n    \t\t\tvar leading = true;\n    \t\t\ttrailing = false;\n    \t\t} else if (isObject(options)) {\n    \t\t\tleading = options.leading;\n    \t\t\tmaxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);\n    \t\t\ttrailing = 'trailing' in options ? options.trailing : trailing;\n    \t\t}\n    \t\tvar delayed = function() {\n    \t\t\tvar remaining = wait - (now() - stamp);\n    \t\t\tif (remaining <= 0) {\n    \t\t\t\tif (maxTimeoutId) {\n    \t\t\t\t\tclearTimeout(maxTimeoutId);\n    \t\t\t\t}\n    \t\t\t\tvar isCalled = trailingCall;\n    \t\t\t\tmaxTimeoutId = timeoutId = trailingCall = undefined;\n    \t\t\t\tif (isCalled) {\n    \t\t\t\t\tlastCalled = now();\n    \t\t\t\t\tresult = func.apply(thisArg, args);\n    \t\t\t\t}\n    \t\t\t} else {\n    \t\t\t\ttimeoutId = setTimeout(delayed, remaining);\n    \t\t\t}\n    \t\t};\n\n    \t\tvar maxDelayed = function() {\n    \t\t\tif (timeoutId) {\n    \t\t\t\tclearTimeout(timeoutId);\n    \t\t\t}\n    \t\t\tmaxTimeoutId = timeoutId = trailingCall = undefined;\n    \t\t\tif (trailing || (maxWait !== wait)) {\n    \t\t\t\tlastCalled = now();\n    \t\t\t\tresult = func.apply(thisArg, args);\n    \t\t\t}\n    \t\t};\n\n    \t\treturn function() {\n    \t\t\targs = arguments;\n    \t\t\tstamp = now();\n    \t\t\tthisArg = this;\n    \t\t\ttrailingCall = trailing && (timeoutId || !leading);\n\n    \t\t\tif (maxWait === false) {\n    \t\t\t\tvar leadingCall = leading && !timeoutId;\n    \t\t\t} else {\n    \t\t\t\tif (!maxTimeoutId && !leading) {\n    \t\t\t\t\tlastCalled = stamp;\n    \t\t\t\t}\n    \t\t\t\tvar remaining = maxWait - (stamp - lastCalled);\n    \t\t\t\tif (remaining <= 0) {\n    \t\t\t\t\tif (maxTimeoutId) {\n    \t\t\t\t\t\tmaxTimeoutId = clearTimeout(maxTimeoutId);\n    \t\t\t\t\t}\n    \t\t\t\t\tlastCalled = stamp;\n    \t\t\t\t\tresult = func.apply(thisArg, args);\n    \t\t\t\t}\n    \t\t\t\telse if (!maxTimeoutId) {\n    \t\t\t\t\tmaxTimeoutId = setTimeout(maxDelayed, remaining);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif (!timeoutId && wait !== maxWait) {\n    \t\t\t\ttimeoutId = setTimeout(delayed, wait);\n    \t\t\t}\n    \t\t\tif (leadingCall) {\n    \t\t\t\tresult = func.apply(thisArg, args);\n    \t\t\t}\n    \t\t\treturn result;\n    \t\t};\n    \t}\n\n    \t/**\n    \t * Defers executing the `func` function until the current call stack has cleared.\n    \t * Additional arguments will be provided to `func` when it is invoked.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {Function} func The function to defer.\n    \t * @param {...*} [arg] Arguments to invoke the function with.\n    \t * @returns {number} Returns the timer id.\n    \t * @example\n    \t *\n    \t * _.defer(function() { console.log('deferred'); });\n    \t * // returns from the function before 'deferred' is logged\n    \t */\n    \tfunction defer(func) {\n    \t\tif (!isFunction(func)) {\n    \t\t\tthrow new TypeError;\n    \t\t}\n    \t\tvar args = nativeSlice.call(arguments, 1);\n    \t\treturn setTimeout(function() { func.apply(undefined, args); }, 1);\n    \t}\n\n    \t/**\n    \t * Executes the `func` function after `wait` milliseconds. Additional arguments\n    \t * will be provided to `func` when it is invoked.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {Function} func The function to delay.\n    \t * @param {number} wait The number of milliseconds to delay execution.\n    \t * @param {...*} [arg] Arguments to invoke the function with.\n    \t * @returns {number} Returns the timer id.\n    \t * @example\n    \t *\n    \t * var log = _.bind(console.log, console);\n    \t * _.delay(log, 1000, 'logged later');\n    \t * // => 'logged later' (Appears after one second.)\n    \t */\n    \tfunction delay(func, wait) {\n    \t\tif (!isFunction(func)) {\n    \t\t\tthrow new TypeError;\n    \t\t}\n    \t\tvar args = nativeSlice.call(arguments, 2);\n    \t\treturn setTimeout(function() { func.apply(undefined, args); }, wait);\n    \t}\n\n    \t/**\n    \t * Creates a function that memoizes the result of `func`. If `resolver` is\n    \t * provided it will be used to determine the cache key for storing the result\n    \t * based on the arguments provided to the memoized function. By default, the\n    \t * first argument provided to the memoized function is used as the cache key.\n    \t * The `func` is executed with the `this` binding of the memoized function.\n    \t * The result cache is exposed as the `cache` property on the memoized function.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {Function} func The function to have its output memoized.\n    \t * @param {Function} [resolver] A function used to resolve the cache key.\n    \t * @returns {Function} Returns the new memoizing function.\n    \t * @example\n    \t *\n    \t * var fibonacci = _.memoize(function(n) {\n       *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n       * });\n    \t *\n    \t * var data = {\n       *   'moe': { 'name': 'moe', 'age': 40 },\n       *   'curly': { 'name': 'curly', 'age': 60 }\n       * };\n    \t *\n    \t * // modifying the result cache\n    \t * var stooge = _.memoize(function(name) { return data[name]; }, _.identity);\n    \t * stooge('curly');\n    \t * // => { 'name': 'curly', 'age': 60 }\n    \t *\n    \t * stooge.cache.curly.name = 'jerome';\n    \t * stooge('curly');\n    \t * // => { 'name': 'jerome', 'age': 60 }\n    \t */\n    \tfunction memoize(func, resolver) {\n    \t\tvar cache = {};\n    \t\treturn function() {\n    \t\t\tvar key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];\n    \t\t\treturn hasOwnProperty.call(cache, key)\n    \t\t\t\t? cache[key]\n    \t\t\t\t: (cache[key] = func.apply(this, arguments));\n    \t\t};\n    \t}\n\n    \t/**\n    \t * Creates a function that is restricted to execute `func` once. Repeat calls to\n    \t * the function will return the value of the first call. The `func` is executed\n    \t * with the `this` binding of the created function.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {Function} func The function to restrict.\n    \t * @returns {Function} Returns the new restricted function.\n    \t * @example\n    \t *\n    \t * var initialize = _.once(createApplication);\n    \t * initialize();\n    \t * initialize();\n    \t * // `initialize` executes `createApplication` once\n    \t */\n    \tfunction once(func) {\n    \t\tvar ran,\n    \t\t\tresult;\n\n    \t\tif (!isFunction(func)) {\n    \t\t\tthrow new TypeError;\n    \t\t}\n    \t\treturn function() {\n    \t\t\tif (ran) {\n    \t\t\t\treturn result;\n    \t\t\t}\n    \t\t\tran = true;\n    \t\t\tresult = func.apply(this, arguments);\n\n    \t\t\t// clear the `func` variable so the function may be garbage collected\n    \t\t\tfunc = null;\n    \t\t\treturn result;\n    \t\t};\n    \t}\n\n    \t/**\n    \t * Creates a function that, when called, invokes `func` with any additional\n    \t * `partial` arguments prepended to those provided to the new function. This\n    \t * method is similar to `_.bind` except it does **not** alter the `this` binding.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {Function} func The function to partially apply arguments to.\n    \t * @param {...*} [arg] Arguments to be partially applied.\n    \t * @returns {Function} Returns the new partially applied function.\n    \t * @example\n    \t *\n    \t * var greet = function(greeting, name) { return greeting + ' ' + name; };\n    \t * var hi = _.partial(greet, 'hi');\n    \t * hi('moe');\n    \t * // => 'hi moe'\n    \t */\n    \tfunction partial(func) {\n    \t\treturn createBound(func, 16, nativeSlice.call(arguments, 1));\n    \t}\n\n    \t/**\n    \t * Creates a function that, when executed, will only call the `func` function\n    \t * at most once per every `wait` milliseconds. Provide an options object to\n    \t * indicate that `func` should be invoked on the leading and/or trailing edge\n    \t * of the `wait` timeout. Subsequent calls to the throttled function will\n    \t * return the result of the last `func` call.\n    \t *\n    \t * Note: If `leading` and `trailing` options are `true` `func` will be called\n    \t * on the trailing edge of the timeout only if the the throttled function is\n    \t * invoked more than once during the `wait` timeout.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {Function} func The function to throttle.\n    \t * @param {number} wait The number of milliseconds to throttle executions to.\n    \t * @param {Object} [options] The options object.\n    \t * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.\n    \t * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n    \t * @returns {Function} Returns the new throttled function.\n    \t * @example\n    \t *\n    \t * // avoid excessively updating the position while scrolling\n    \t * var throttled = _.throttle(updatePosition, 100);\n    \t * jQuery(window).on('scroll', throttled);\n    \t *\n    \t * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes\n    \t * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n       *   'trailing': false\n       * }));\n    \t */\n    \tfunction throttle(func, wait, options) {\n    \t\tvar leading = true,\n    \t\t\ttrailing = true;\n\n    \t\tif (!isFunction(func)) {\n    \t\t\tthrow new TypeError;\n    \t\t}\n    \t\tif (options === false) {\n    \t\t\tleading = false;\n    \t\t} else if (isObject(options)) {\n    \t\t\tleading = 'leading' in options ? options.leading : leading;\n    \t\t\ttrailing = 'trailing' in options ? options.trailing : trailing;\n    \t\t}\n    \t\toptions = {};\n    \t\toptions.leading = leading;\n    \t\toptions.maxWait = wait;\n    \t\toptions.trailing = trailing;\n\n    \t\treturn debounce(func, wait, options);\n    \t}\n\n    \t/**\n    \t * Creates a function that provides `value` to the wrapper function as its\n    \t * first argument. Additional arguments provided to the function are appended\n    \t * to those provided to the wrapper function. The wrapper is executed with\n    \t * the `this` binding of the created function.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Functions\n    \t * @param {*} value The value to wrap.\n    \t * @param {Function} wrapper The wrapper function.\n    \t * @returns {Function} Returns the new function.\n    \t * @example\n    \t *\n    \t * var hello = function(name) { return 'hello ' + name; };\n    \t * hello = _.wrap(hello, function(func) {\n       *   return 'before, ' + func('moe') + ', after';\n       * });\n    \t * hello();\n    \t * // => 'before, hello moe, after'\n    \t */\n    \tfunction wrap(value, wrapper) {\n    \t\tif (!isFunction(wrapper)) {\n    \t\t\tthrow new TypeError;\n    \t\t}\n    \t\treturn function() {\n    \t\t\tvar args = [value];\n    \t\t\tpush.apply(args, arguments);\n    \t\t\treturn wrapper.apply(this, args);\n    \t\t};\n    \t}\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t/**\n    \t * Converts the characters `&`, `<`, `>`, `\"`, and `'` in `string` to their\n    \t * corresponding HTML entities.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Utilities\n    \t * @param {string} string The string to escape.\n    \t * @returns {string} Returns the escaped string.\n    \t * @example\n    \t *\n    \t * _.escape('Moe, Larry & Curly');\n    \t * // => 'Moe, Larry &amp; Curly'\n    \t */\n    \tfunction escape(string) {\n    \t\treturn string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);\n    \t}\n\n    \t/**\n    \t * This method returns the first argument provided to it.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Utilities\n    \t * @param {*} value Any value.\n    \t * @returns {*} Returns `value`.\n    \t * @example\n    \t *\n    \t * var moe = { 'name': 'moe' };\n    \t * moe === _.identity(moe);\n    \t * // => true\n    \t */\n    \tfunction identity(value) {\n    \t\treturn value;\n    \t}\n\n    \t/**\n    \t * Adds function properties of a source object to the `lodash` function and\n    \t * chainable wrapper.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Utilities\n    \t * @param {Object} object The object of function properties to add to `lodash`.\n    \t * @param {Object} object The object of function properties to add to `lodash`.\n    \t * @example\n    \t *\n    \t * _.mixin({\n       *   'capitalize': function(string) {\n       *     return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n       *   }\n       * });\n    \t *\n    \t * _.capitalize('moe');\n    \t * // => 'Moe'\n    \t *\n    \t * _('moe').capitalize();\n    \t * // => 'Moe'\n    \t */\n    \tfunction mixin(object) {\n    \t\tforEach(functions(object), function(methodName) {\n    \t\t\tvar func = lodash[methodName] = object[methodName];\n\n    \t\t\tlodash.prototype[methodName] = function() {\n    \t\t\t\tvar args = [this.__wrapped__];\n    \t\t\t\tpush.apply(args, arguments);\n\n    \t\t\t\tvar result = func.apply(lodash, args);\n    \t\t\t\treturn this.__chain__\n    \t\t\t\t\t? new lodashWrapper(result, true)\n    \t\t\t\t\t: result;\n    \t\t\t};\n    \t\t});\n    \t}\n\n    \t/**\n    \t * Reverts the '_' variable to its previous value and returns a reference to\n    \t * the `lodash` function.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Utilities\n    \t * @returns {Function} Returns the `lodash` function.\n    \t * @example\n    \t *\n    \t * var lodash = _.noConflict();\n    \t */\n    \tfunction noConflict() {\n    \t\troot._ = oldDash;\n    \t\treturn this;\n    \t}\n\n    \t/**\n    \t * Produces a random number between `min` and `max` (inclusive). If only one\n    \t * argument is provided a number between `0` and the given number will be\n    \t * returned. If `floating` is truey or either `min` or `max` are floats a\n    \t * floating-point number will be returned instead of an integer.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Utilities\n    \t * @param {number} [min=0] The minimum possible value.\n    \t * @param {number} [max=1] The maximum possible value.\n    \t * @param {boolean} [floating=false] Specify returning a floating-point number.\n    \t * @returns {number} Returns a random number.\n    \t * @example\n    \t *\n    \t * _.random(0, 5);\n    \t * // => an integer between 0 and 5\n    \t *\n    \t * _.random(5);\n    \t * // => also an integer between 0 and 5\n    \t *\n    \t * _.random(5, true);\n    \t * // => a floating-point number between 0 and 5\n    \t *\n    \t * _.random(1.2, 5.2);\n    \t * // => a floating-point number between 1.2 and 5.2\n    \t */\n    \tfunction random(min, max) {\n    \t\tif (min == null && max == null) {\n    \t\t\tmax = 1;\n    \t\t}\n    \t\tmin = +min || 0;\n    \t\tif (max == null) {\n    \t\t\tmax = min;\n    \t\t\tmin = 0;\n    \t\t} else {\n    \t\t\tmax = +max || 0;\n    \t\t}\n    \t\treturn min + floor(nativeRandom() * (max - min + 1));\n    \t}\n\n    \t/**\n    \t * Resolves the value of `property` on `object`. If `property` is a function\n    \t * it will be invoked with the `this` binding of `object` and its result returned,\n    \t * else the property value is returned. If `object` is falsey then `undefined`\n    \t * is returned.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Utilities\n    \t * @param {Object} object The object to inspect.\n    \t * @param {string} property The property to get the value of.\n    \t * @returns {*} Returns the resolved value.\n    \t * @example\n    \t *\n    \t * var object = {\n       *   'cheese': 'crumpets',\n       *   'stuff': function() {\n       *     return 'nonsense';\n       *   }\n       * };\n    \t *\n    \t * _.result(object, 'cheese');\n    \t * // => 'crumpets'\n    \t *\n    \t * _.result(object, 'stuff');\n    \t * // => 'nonsense'\n    \t */\n    \tfunction result(object, property) {\n    \t\tif (object) {\n    \t\t\tvar value = object[property];\n    \t\t\treturn isFunction(value) ? object[property]() : value;\n    \t\t}\n    \t}\n\n    \t/**\n    \t * A micro-templating method that handles arbitrary delimiters, preserves\n    \t * whitespace, and correctly escapes quotes within interpolated code.\n    \t *\n    \t * Note: In the development build, `_.template` utilizes sourceURLs for easier\n    \t * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n    \t *\n    \t * For more information on precompiling templates see:\n    \t * http://lodash.com/#custom-builds\n    \t *\n    \t * For more information on Chrome extension sandboxes see:\n    \t * http://developer.chrome.com/stable/extensions/sandboxingEval.html\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Utilities\n    \t * @param {string} text The template text.\n    \t * @param {Object} data The data object used to populate the text.\n    \t * @param {Object} [options] The options object.\n    \t * @param {RegExp} [options.escape] The \"escape\" delimiter.\n    \t * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n    \t * @param {Object} [options.imports] An object to import into the template as local variables.\n    \t * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n    \t * @param {string} [sourceURL] The sourceURL of the template's compiled source.\n    \t * @param {string} [variable] The data object variable name.\n    \t * @returns {Function|string} Returns a compiled function when no `data` object\n    \t *  is given, else it returns the interpolated text.\n    \t * @example\n    \t *\n    \t * // using the \"interpolate\" delimiter to create a compiled template\n    \t * var compiled = _.template('hello <%= name %>');\n    \t * compiled({ 'name': 'moe' });\n    \t * // => 'hello moe'\n    \t *\n    \t * // using the \"escape\" delimiter to escape HTML in data property values\n    \t * _.template('<b><%- value %></b>', { 'value': '<script>' });\n    \t * // => '<b>&lt;script&gt;</b>'\n    \t *\n    \t * // using the \"evaluate\" delimiter to generate HTML\n    \t * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';\n    \t * _.template(list, { 'people': ['moe', 'larry'] });\n    \t * // => '<li>moe</li><li>larry</li>'\n    \t *\n    \t * // using the ES6 delimiter as an alternative to the default \"interpolate\" delimiter\n    \t * _.template('hello ${ name }', { 'name': 'curly' });\n    \t * // => 'hello curly'\n    \t *\n    \t * // using the internal `print` function in \"evaluate\" delimiters\n    \t * _.template('<% print(\"hello \" + name); %>!', { 'name': 'larry' });\n    \t * // => 'hello larry!'\n    \t *\n    \t * // using a custom template delimiters\n    \t * _.templateSettings = {\n       *   'interpolate': /{{([\\s\\S]+?)}}/g\n       * };\n    \t *\n    \t * _.template('hello {{ name }}!', { 'name': 'mustache' });\n    \t * // => 'hello mustache!'\n    \t *\n    \t * // using the `imports` option to import jQuery\n    \t * var list = '<% $.each(people, function(name) { %><li><%- name %></li><% }); %>';\n    \t * _.template(list, { 'people': ['moe', 'larry'] }, { 'imports': { '$': jQuery } });\n    \t * // => '<li>moe</li><li>larry</li>'\n    \t *\n    \t * // using the `sourceURL` option to specify a custom sourceURL for the template\n    \t * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });\n    \t * compiled(data);\n    \t * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n    \t *\n    \t * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n    \t * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });\n    \t * compiled.source;\n    \t * // => function(data) {\n       *   var __t, __p = '', __e = _.escape;\n       *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';\n       *   return __p;\n       * }\n    \t *\n    \t * // using the `source` property to inline compiled templates for meaningful\n    \t * // line numbers in error messages and a stack trace\n    \t * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n    \t *   var JST = {\\\n       *     \"main\": ' + _.template(mainText).source + '\\\n       *   };\\\n    \t * ');\n    \t */\n    \tfunction template(text, data, options) {\n    \t\tvar _ = lodash,\n    \t\t\tsettings = _.templateSettings;\n\n    \t\ttext || (text = '');\n    \t\toptions = defaults({}, options, settings);\n\n    \t\tvar index = 0,\n    \t\t\tsource = \"__p += '\",\n    \t\t\tvariable = options.variable;\n\n    \t\tvar reDelimiters = RegExp(\n    \t\t\t(options.escape || reNoMatch).source + '|' +\n    \t\t\t\t(options.interpolate || reNoMatch).source + '|' +\n    \t\t\t\t(options.evaluate || reNoMatch).source + '|$'\n    \t\t\t, 'g');\n\n    \t\ttext.replace(reDelimiters, function(match, escapeValue, interpolateValue, evaluateValue, offset) {\n    \t\t\tsource += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n    \t\t\tif (escapeValue) {\n    \t\t\t\tsource += \"' +\\n_.escape(\" + escapeValue + \") +\\n'\";\n    \t\t\t}\n    \t\t\tif (evaluateValue) {\n    \t\t\t\tsource += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n    \t\t\t}\n    \t\t\tif (interpolateValue) {\n    \t\t\t\tsource += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n    \t\t\t}\n    \t\t\tindex = offset + match.length;\n    \t\t\treturn match;\n    \t\t});\n\n    \t\tsource += \"';\\n\";\n    \t\tif (!variable) {\n    \t\t\tvariable = 'obj';\n    \t\t\tsource = 'with (' + variable + ' || {}) {\\n' + source + '\\n}\\n';\n    \t\t}\n    \t\tsource = 'function(' + variable + ') {\\n' +\n    \t\t\t\"var __t, __p = '', __j = Array.prototype.join;\\n\" +\n    \t\t\t\"function print() { __p += __j.call(arguments, '') }\\n\" +\n    \t\t\tsource +\n    \t\t\t'return __p\\n}';\n\n    \t\ttry {\n    \t\t\tvar result = Function('_', 'return ' + source)(_);\n    \t\t} catch(e) {\n    \t\t\te.source = source;\n    \t\t\tthrow e;\n    \t\t}\n    \t\tif (data) {\n    \t\t\treturn result(data);\n    \t\t}\n    \t\tresult.source = source;\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * Executes the callback `n` times, returning an array of the results\n    \t * of each callback execution. The callback is bound to `thisArg` and invoked\n    \t * with one argument; (index).\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Utilities\n    \t * @param {number} n The number of times to execute the callback.\n    \t * @param {Function} callback The function called per iteration.\n    \t * @param {*} [thisArg] The `this` binding of `callback`.\n    \t * @returns {Array} Returns an array of the results of each `callback` execution.\n    \t * @example\n    \t *\n    \t * var diceRolls = _.times(3, _.partial(_.random, 1, 6));\n    \t * // => [3, 6, 4]\n    \t *\n    \t * _.times(3, function(n) { mage.castSpell(n); });\n    \t * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively\n    \t *\n    \t * _.times(3, function(n) { this.cast(n); }, mage);\n    \t * // => also calls `mage.castSpell(n)` three times\n    \t */\n    \tfunction times(n, callback, thisArg) {\n    \t\tn = (n = +n) > -1 ? n : 0;\n    \t\tvar index = -1,\n    \t\t\tresult = Array(n);\n\n    \t\tcallback = baseCreateCallback(callback, thisArg, 1);\n    \t\twhile (++index < n) {\n    \t\t\tresult[index] = callback(index);\n    \t\t}\n    \t\treturn result;\n    \t}\n\n    \t/**\n    \t * The inverse of `_.escape` this method converts the HTML entities\n    \t * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their\n    \t * corresponding characters.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Utilities\n    \t * @param {string} string The string to unescape.\n    \t * @returns {string} Returns the unescaped string.\n    \t * @example\n    \t *\n    \t * _.unescape('Moe, Larry &amp; Curly');\n    \t * // => 'Moe, Larry & Curly'\n    \t */\n    \tfunction unescape(string) {\n    \t\treturn string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);\n    \t}\n\n    \t/**\n    \t * Generates a unique ID. If `prefix` is provided the ID will be appended to it.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Utilities\n    \t * @param {string} [prefix] The value to prefix the ID with.\n    \t * @returns {string} Returns the unique ID.\n    \t * @example\n    \t *\n    \t * _.uniqueId('contact_');\n    \t * // => 'contact_104'\n    \t *\n    \t * _.uniqueId();\n    \t * // => '105'\n    \t */\n    \tfunction uniqueId(prefix) {\n    \t\tvar id = ++idCounter + '';\n    \t\treturn prefix ? prefix + id : id;\n    \t}\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t/**\n    \t * Creates a `lodash` object that wraps the given value with explicit\n    \t * method chaining enabled.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Chaining\n    \t * @param {*} value The value to wrap.\n    \t * @returns {Object} Returns the wrapper object.\n    \t * @example\n    \t *\n    \t * var stooges = [\n    \t *   { 'name': 'moe', 'age': 40 },\n    \t *   { 'name': 'larry', 'age': 50 },\n    \t *   { 'name': 'curly', 'age': 60 }\n    \t * ];\n    \t *\n    \t * var youngest = _.chain(stooges)\n    \t *     .sortBy('age')\n    \t *     .map(function(stooge) { return stooge.name + ' is ' + stooge.age; })\n    \t *     .first()\n    \t *     .value();\n    \t * // => 'moe is 40'\n    \t */\n    \tfunction chain(value) {\n    \t\tvalue = new lodashWrapper(value);\n    \t\tvalue.__chain__ = true;\n    \t\treturn value;\n    \t}\n\n    \t/**\n    \t * Invokes `interceptor` with the `value` as the first argument and then\n    \t * returns `value`. The purpose of this method is to \"tap into\" a method\n    \t * chain in order to perform operations on intermediate results within\n    \t * the chain.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @category Chaining\n    \t * @param {*} value The value to provide to `interceptor`.\n    \t * @param {Function} interceptor The function to invoke.\n    \t * @returns {*} Returns `value`.\n    \t * @example\n    \t *\n    \t * _([1, 2, 3, 4])\n    \t *  .filter(function(num) { return num % 2 == 0; })\n    \t *  .tap(function(array) { console.log(array); })\n    \t *  .map(function(num) { return num * num; })\n    \t *  .value();\n    \t * // => // [2, 4] (logged)\n    \t * // => [4, 16]\n    \t */\n    \tfunction tap(value, interceptor) {\n    \t\tinterceptor(value);\n    \t\treturn value;\n    \t}\n\n    \t/**\n    \t * Enables explicit method chaining on the wrapper object.\n    \t *\n    \t * @name chain\n    \t * @memberOf _\n    \t * @category Chaining\n    \t * @returns {*} Returns the wrapper object.\n    \t * @example\n    \t *\n    \t * var stooges = [\n    \t *   { 'name': 'moe', 'age': 40 },\n    \t *   { 'name': 'larry', 'age': 50 }\n    \t * ];\n    \t *\n    \t * // without explicit chaining\n    \t * _(stooges).first();\n    \t * // => { 'name': 'moe', 'age': 40 }\n    \t *\n    \t * // with explicit chaining\n    \t * _(stooges).chain()\n    \t *   .first()\n    \t *   .pick('age')\n    \t *   .value()\n    \t * // => { 'age': 40 }\n    \t */\n    \tfunction wrapperChain() {\n    \t\tthis.__chain__ = true;\n    \t\treturn this;\n    \t}\n\n    \t/**\n    \t * Extracts the wrapped value.\n    \t *\n    \t * @name valueOf\n    \t * @memberOf _\n    \t * @alias value\n    \t * @category Chaining\n    \t * @returns {*} Returns the wrapped value.\n    \t * @example\n    \t *\n    \t * _([1, 2, 3]).valueOf();\n    \t * // => [1, 2, 3]\n    \t */\n    \tfunction wrapperValueOf() {\n    \t\treturn this.__wrapped__;\n    \t}\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t// add functions that return wrapped values when chaining\n    \tlodash.after = after;\n    \tlodash.bind = bind;\n    \tlodash.bindAll = bindAll;\n    \tlodash.chain = chain;\n    \tlodash.compact = compact;\n    \tlodash.compose = compose;\n    \tlodash.countBy = countBy;\n    \tlodash.debounce = debounce;\n    \tlodash.defaults = defaults;\n    \tlodash.defer = defer;\n    \tlodash.delay = delay;\n    \tlodash.difference = difference;\n    \tlodash.filter = filter;\n    \tlodash.flatten = flatten;\n    \tlodash.forEach = forEach;\n    \tlodash.functions = functions;\n    \tlodash.groupBy = groupBy;\n    \tlodash.indexBy = indexBy;\n    \tlodash.initial = initial;\n    \tlodash.intersection = intersection;\n    \tlodash.invert = invert;\n    \tlodash.invoke = invoke;\n    \tlodash.keys = keys;\n    \tlodash.map = map;\n    \tlodash.max = max;\n    \tlodash.memoize = memoize;\n    \tlodash.min = min;\n    \tlodash.omit = omit;\n    \tlodash.once = once;\n    \tlodash.pairs = pairs;\n    \tlodash.partial = partial;\n    \tlodash.pick = pick;\n    \tlodash.pluck = pluck;\n    \tlodash.range = range;\n    \tlodash.reject = reject;\n    \tlodash.rest = rest;\n    \tlodash.shuffle = shuffle;\n    \tlodash.sortBy = sortBy;\n    \tlodash.tap = tap;\n    \tlodash.throttle = throttle;\n    \tlodash.times = times;\n    \tlodash.toArray = toArray;\n    \tlodash.union = union;\n    \tlodash.uniq = uniq;\n    \tlodash.values = values;\n    \tlodash.where = where;\n    \tlodash.without = without;\n    \tlodash.wrap = wrap;\n    \tlodash.zip = zip;\n\n    \t// add aliases\n    \tlodash.collect = map;\n    \tlodash.drop = rest;\n    \tlodash.each = forEach;\n    \tlodash.extend = assign;\n    \tlodash.methods = functions;\n    \tlodash.object = zipObject;\n    \tlodash.select = filter;\n    \tlodash.tail = rest;\n    \tlodash.unique = uniq;\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t// add functions that return unwrapped values when chaining\n    \tlodash.clone = clone;\n    \tlodash.contains = contains;\n    \tlodash.escape = escape;\n    \tlodash.every = every;\n    \tlodash.find = find;\n    \tlodash.has = has;\n    \tlodash.identity = identity;\n    \tlodash.indexOf = indexOf;\n    \tlodash.isArguments = isArguments;\n    \tlodash.isArray = isArray;\n    \tlodash.isBoolean = isBoolean;\n    \tlodash.isDate = isDate;\n    \tlodash.isElement = isElement;\n    \tlodash.isEmpty = isEmpty;\n    \tlodash.isEqual = isEqual;\n    \tlodash.isFinite = isFinite;\n    \tlodash.isFunction = isFunction;\n    \tlodash.isNaN = isNaN;\n    \tlodash.isNull = isNull;\n    \tlodash.isNumber = isNumber;\n    \tlodash.isObject = isObject;\n    \tlodash.isRegExp = isRegExp;\n    \tlodash.isString = isString;\n    \tlodash.isUndefined = isUndefined;\n    \tlodash.lastIndexOf = lastIndexOf;\n    \tlodash.mixin = mixin;\n    \tlodash.noConflict = noConflict;\n    \tlodash.random = random;\n    \tlodash.reduce = reduce;\n    \tlodash.reduceRight = reduceRight;\n    \tlodash.result = result;\n    \tlodash.size = size;\n    \tlodash.some = some;\n    \tlodash.sortedIndex = sortedIndex;\n    \tlodash.template = template;\n    \tlodash.unescape = unescape;\n    \tlodash.uniqueId = uniqueId;\n\n    \t// add aliases\n    \tlodash.all = every;\n    \tlodash.any = some;\n    \tlodash.detect = find;\n    \tlodash.findWhere = findWhere;\n    \tlodash.foldl = reduce;\n    \tlodash.foldr = reduceRight;\n    \tlodash.include = contains;\n    \tlodash.inject = reduce;\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t// add functions capable of returning wrapped and unwrapped values when chaining\n    \tlodash.first = first;\n    \tlodash.last = last;\n    \tlodash.sample = sample;\n\n    \t// add aliases\n    \tlodash.take = first;\n    \tlodash.head = first;\n\n    \t/*--------------------------------------------------------------------------*/\n\n    \t// add functions to `lodash.prototype`\n    \tmixin(lodash);\n\n    \t/**\n    \t * The semantic version number.\n    \t *\n    \t * @static\n    \t * @memberOf _\n    \t * @type string\n    \t */\n    \tlodash.VERSION = '2.2.1';\n\n    \t// add \"Chaining\" functions to the wrapper\n    \tlodash.prototype.chain = wrapperChain;\n    \tlodash.prototype.value = wrapperValueOf;\n\n    \t// add `Array` mutator functions to the wrapper\n    \tforEach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n    \t\tvar func = arrayRef[methodName];\n    \t\tlodash.prototype[methodName] = function() {\n    \t\t\tvar value = this.__wrapped__;\n    \t\t\tfunc.apply(value, arguments);\n\n    \t\t\t// avoid array-like object bugs with `Array#shift` and `Array#splice`\n    \t\t\t// in Firefox < 10 and IE < 9\n    \t\t\tif (!support.spliceObjects && value.length === 0) {\n    \t\t\t\tdelete value[0];\n    \t\t\t}\n    \t\t\treturn this;\n    \t\t};\n    \t});\n\n    \t// add `Array` accessor functions to the wrapper\n    \tforEach(['concat', 'join', 'slice'], function(methodName) {\n    \t\tvar func = arrayRef[methodName];\n    \t\tlodash.prototype[methodName] = function() {\n    \t\t\tvar value = this.__wrapped__,\n    \t\t\t\tresult = func.apply(value, arguments);\n\n    \t\t\tif (this.__chain__) {\n    \t\t\t\tresult = new lodashWrapper(result);\n    \t\t\t\tresult.__chain__ = true;\n    \t\t\t}\n    \t\t\treturn result;\n    \t\t};\n    \t});\n\n\n\n    \t\t// in a browser or Rhino\n//    \t\troot._ = lodash;\n\t\t    lodash.extend(ns, lodash);\n    }.call(ns));\n\n})(use('spirit._helpers'));\n\n/* jshint ignore:end */\n","(function(ns) {\n\n\t'use strict';\n\n\tvar ctor = function() {};\n\n\t/**\n\t * Borrowed from Backbone.extend\n\t * @param protoProps {{}}\n\t * @param staticProps {{}}\n\t * @returns {{}}\n\t */\n\tns.extendObject = function(protoProps, staticProps) {\n\t\tvar parent = this;\n\t\tvar child;\n\n\t\tif (protoProps && ns.has(protoProps, 'constructor')) {\n\t\t\tchild = protoProps.constructor;\n\t\t} else {\n\t\t\tchild = function() { return parent.apply(this, arguments); };\n\t\t}\n\n\t\tns.extend(child, parent, staticProps);\n\n\t\tvar Surrogate = function() { this.constructor = child; };\n\t\tSurrogate.prototype = parent.prototype;\n\t\tchild.prototype = new Surrogate();\n\n\t\tif (protoProps) {\n\t\t\tns.extend(child.prototype, protoProps);\n\t\t}\n\n\t\t/* jshint -W106 */\n\t\tchild.__super__ = parent.prototype;\n\n\t\treturn child;\n\t};\n\n\t/**\n\t * extendObjectWithSuper\n\t * Borrowed from https://github.com/lukasolson/Backbone-Super\n\t * Now we can use this._super() everywhere we extend Spirit\n\t * @param parent\n\t * @param protoProps\n\t * @param staticProps\n\t * @returns {*}\n\t */\n\tvar inherits = function(parent, protoProps, staticProps) {\n\t\t/* jshint -W030 */\n\t\t/* jshint -W055 */\n\t\t/* jshint -W116 */\n\t\t/* jshint -W083 */\n\t\t/* jshint -W106 */\n\t\tvar child,\n\t\t\t_super = parent.prototype,\n\t\t\tfnTest = /xyz/.test(function(xyz) {xyz;}) ? /\\b_super\\b/ : /.*/;\n\n\t\tif (protoProps && protoProps.hasOwnProperty('constructor')) {\n\t\t\tchild = protoProps.constructor;\n\t\t} else {\n\t\t\tchild = function() { parent.apply(this, arguments); };\n\t\t}\n\n\t\t// Inherit class (static) properties from parent.\n\t\tns.extend(child, parent);\n\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tctor.prototype = parent.prototype;\n\t\tchild.prototype = new ctor();\n\n\t\t// Add prototype properties (instance properties) to the subclass,\n\t\t// if supplied.\n\t\tif (protoProps) {\n\t\t\tns.extend(child.prototype, protoProps);\n\n\t\t\t// Copy the properties over onto the new prototype\n\t\t\tfor (var name in protoProps) {\n\t\t\t\t// Check if we're overwriting an existing function\n\t\t\t\tif (typeof protoProps[name] == \"function\" && typeof _super[name] == \"function\" && fnTest.test(protoProps[name])) {\n\t\t\t\t\tchild.prototype[name] = (function(name, fn) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar tmp = this._super;\n\n\t\t\t\t\t\t\t// Add a new ._super() method that is the same method\n\t\t\t\t\t\t\t// but on the super-class\n\t\t\t\t\t\t\tthis._super = _super[name];\n\n\t\t\t\t\t\t\t// The method only need to be bound temporarily, so we\n\t\t\t\t\t\t\t// remove it when we're done executing\n\t\t\t\t\t\t\tvar ret = fn.apply(this, arguments);\n\t\t\t\t\t\t\tthis._super = tmp;\n\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t};\n\t\t\t\t\t})(name, protoProps[name]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add static properties to the constructor function, if supplied.\n\t\tif (staticProps) {\n\t\t\tns.extend(child, staticProps);\n\t\t}\n\n\t\t// Correctly set child's `prototype.constructor`.\n\t\tchild.prototype.constructor = child;\n\n\t\t// Set a convenience property in case the parent's prototype is needed later.\n\t\tchild.__super__ = parent.prototype;\n\n\t\treturn child;\n\t};\n\tns.extendObjectWithSuper = function(protoProps, classProps) {\n\t\tvar child = inherits(this, protoProps, classProps);\n\t\tchild.extend = ns.extendObject;\n\t\treturn child;\n\t};\n\n\t/**\n\t * Autobind all methods to scope!\n\t * @param scope\n\t */\n\tns.autoBind = function(scope) {\n\t\tvar funcs = ns.functions(scope.constructor.prototype);\n\t\tns.each(funcs, function(f) {\n\t\t\tif (f.charAt(0) !== '_' && ns.indexOf(['autoBind', 'constructor'], f) === -1) {\n\t\t\t\tscope[f] = ns.bind(scope[f], scope);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Check if we are running in test mode?\n\t * @returns {boolean}\n\t */\n\tns.testMode = function() {\n\t\t/* jshint -W106 */\n\t\treturn !!(window.__karma__);\n\t};\n\n})(use('spirit._helpers'));\n","\n/**\n * Determine debug mode\n * @type {Boolean}\n */\nvar debug = true;\n\n/**\n * Make helpers globally available\n * @type {Object}\n */\nvar _ = use('spirit._helpers');\n\n/**\n * Prints log messages in debug mode\n * @returns {Boolean}\n */\nvar log = function() {\n\t/* jshint -W106 */\n\t/* jshint -W116 */\n\tif (!!(window.__karma__)) {\n\t\treturn false;\n\t}\n\n\tif (window.console && _.isFunction(window.console.log)) {\n\t\tvar args = [].slice.call(arguments);\n\t\targs.unshift('Spirit: ->');\n\t\tconsole.log.apply(console, args);\n\t}\n\n\treturn true;\n};\n\n/**\n * Global defaults\n * @type {Object}\n */\nvar globalDefaults = {\n\ttween: _.isFunction(window.TweenMax) ? window.TweenMax : window.TweenLite,\n\ttimeline: _.isFunction(window.TimelineMax) ? window.TimelineMax : window.TimelineLite\n};\n","(function(ns) {\n\n  'use strict';\n\n  ns.Timeline = ns.Abstract.extend({\n\n    defaults: {\n      el: null,\n      id: null,\n      transitions: 'spirit.collection.Transitions'\n    },\n\n    /**\n     * Initialize\n     * This model can be constructed by json data or by assigning real values.\n     * @returns {ns.Timeline}\n     */\n    initialize: function() {\n      _.autoBind(this);\n\n      if (this.get('el') instanceof $) {\n        this.bindModelToElement();\n        this.applyMappings();\n      } else {\n        var selector = '[data-spirit-id=' + this.get('id') + ']',\n            $el = $(selector);\n\n        if ($el.length > 0) {\n          this.set({el: $($el.get(0))}, {silent: true});\n          this.bindModelToElement();\n          this.applyMappings();\n        } else {\n          throw new Error('[spirit.model.Timeline] Can\\'t apply timeline on element. Element: ' + selector + ' can\\'t be found');\n        }\n      }\n\n      // apply bubbling events\n      this.get('transitions').on('change change:params', _.bind(function(e){\n        this.trigger('change:transitions', e);\n      }, this));\n\n      return this;\n    },\n\n    /**\n     * Bind this model to element\n     * Retrieve this model by DOM element: $(..).data('spirit-model');\n     * @returns {ns.Timeline}\n     */\n    bindModelToElement: function() {\n      this.get('el').data('spirit-model', this);\n      return this;\n    },\n\n    /**\n     * Apply mappings on transitions\n     * @returns {ns.Timeline}\n     */\n    applyMappings: function() {\n      this.get('transitions').mappings.push(\n        new (use('spirit.model.vo').RegExpMapping)(\n          /\\$this/g,\n          this.get('el')\n        )\n      );\n    },\n\n    destroy: function() {\n      this.get('transitions').mappings = [];\n      if (this.get('el')) {\n        this.get('el').data('spirit-model', null);\n      }\n      this._super();\n    }\n\n  });\n\n})(use('spirit.model'));\n","(function(ns) {\n  'use strict';\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // Implement fancy features of the Events API such as multiple event\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n  // in terms of the existing API.\n  var eventsApi = function(obj, action, name, rest) {\n\n    if (!name) {\n      return true;\n    }\n\n    // Handle event maps.\n    if (typeof name === 'object') {\n      for (var key in name) {\n        obj[action].apply(obj, [key, name[key]].concat(rest));\n      }\n      return false;\n    }\n\n    // Handle space separated event names.\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        obj[action].apply(obj, [names[i]].concat(rest));\n      }\n      return false;\n    }\n\n    return true;\n  };\n\n  // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n  var triggerEvents = function(events, args) {\n    /* jshint -W116 */\n\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n      case 0:\n        while (++i < l) {\n          (ev = events[i]).callback.call(ev.ctx);\n        }\n        return;\n      case 1:\n        while (++i < l) {\n          (ev = events[i]).callback.call(ev.ctx, a1);\n        }\n        return;\n      case 2:\n        while (++i < l) {\n          (ev = events[i]).callback.call(ev.ctx, a1, a2);\n        }\n        return;\n      case 3:\n        while (++i < l) {\n          (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n        }\n        return;\n      default:\n        while (++i < l) {\n          (ev = events[i]).callback.apply(ev.ctx, args);\n        }\n    }\n  };\n\n\n  /**\n   * Event Dispatcher borrowed from backbonejs\n   * @type {{on: Function, once: Function, off: Function, trigger: Function, stopListening: Function}}\n   */\n  ns.Events = {\n\n    /* jshint -W030 */\n    /* jshint -W084 */\n\n\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    on: function(name, callback, context) {\n      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) {\n        return this;\n      }\n      this._events || (this._events = {});\n      var events = this._events[name] || (this._events[name] = []);\n      events.push({callback: callback, context: context, ctx: context || this});\n      return this;\n    },\n\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, it will be removed.\n    once: function(name, callback, context) {\n      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) {\n        return this;\n      }\n      var self = this;\n      var once = _.once(function() {\n        self.off(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n      return this.on(name, once, context);\n    },\n\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    off: function(name, callback, context) {\n      var retain, ev, events, names, i, l, j, k;\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) {\n        return this;\n      }\n      if (!name && !callback && !context) {\n        this._events = {};\n        return this;\n      }\n      names = name ? [name] : _.keys(this._events);\n      for (i = 0, l = names.length; i < l; i++) {\n        name = names[i];\n        if (events = this._events[name]) {\n          this._events[name] = retain = [];\n          if (callback || context) {\n            for (j = 0, k = events.length; j < k; j++) {\n              ev = events[j];\n              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n                (context && context !== ev.context)) {\n                retain.push(ev);\n              }\n            }\n          }\n          if (!retain.length) {\n            delete this._events[name];\n          }\n        }\n      }\n\n      return this;\n    },\n\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function(name) {\n      if (!this._events) {\n        return this;\n      }\n      var args = [].slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', name, args)) {\n        return this;\n      }\n      var events = this._events[name];\n      var allEvents = this._events.all;\n      if (events) {\n        triggerEvents(events, args);\n      }\n      if (allEvents) {\n        triggerEvents(allEvents, arguments);\n      }\n      return this;\n    },\n\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    stopListening: function(obj, name, callback) {\n      var listeningTo = this._listeningTo;\n      if (!listeningTo) {\n        return this;\n      }\n      var remove = !name && !callback;\n      if (!callback && typeof name === 'object') {\n        callback = this;\n      }\n      if (obj) {\n        (listeningTo = {})[obj._listenId] = obj;\n      }\n      for (var id in listeningTo) {\n        obj = listeningTo[id];\n        obj.off(name, callback, this);\n        if (remove || _.isEmpty(obj._events)) {\n          delete this._listeningTo[id];\n        }\n      }\n      return this;\n    }\n\n  };\n\n})(use('spirit.event'));\n","/* jshint ignore:start */\n\n(function(ns) {\n\n\t'use strict';\n\n\t// Default options for `Collection#set`.\n\tvar setOptions = {add: true, remove: true, merge: true};\n\tvar addOptions = {add: true, remove: false};\n\n\tns.Abstract = function(models, options) {\n\n\t\t// parse model!\n\t\tthis.model = exist(this.model) ? use(this.model) : use('spirit.model').Abstract;\n\n\t\toptions || (options = {});\n\t\tif (options.model) {\n\t\t\tthis.model = options.model;\n\t\t}\n\t\tif (options.comparator !== void 0) {\n\t\t\tthis.comparator = options.comparator;\n\t\t}\n\t\tthis._reset();\n\t\tthis.initialize.apply(this, arguments);\n\t\tif (models) {\n\t\t\tthis.reset(models, _.extend({silent: true}, options));\n\t\t}\n\t};\n\n\tns.Abstract.extend = _.extendObjectWithSuper;\n\t_.extend(ns.Abstract.prototype, use('spirit.event').Events, {\n\n\t\t// The default model for a collection is just a **Backbone.Model**.\n\t\t// This should be overridden in most cases.\n\t\tmodel: 'spirit.model.Abstract',\n\n\t\t// Initialize is an empty function by default. Override it with your own\n\t\t// initialization logic.\n\t\tinitialize: function() {},\n\n\t\t// The JSON representation of a Collection is an array of the\n\t\t// models' attributes.\n\t\ttoJSON: function(options) {\n\t\t\treturn this.map(function(model) { return model.toJSON(options); });\n\t\t},\n\n\t\t// Add a model, or list of models to the set.\n\t\tadd: function(models, options) {\n\t\t\treturn this.set(models, _.extend({merge: false}, options, addOptions));\n\t\t},\n\n\t\t// Remove a model, or a list of models from the set.\n\t\tremove: function(models, options) {\n\t\t\tvar singular = !_.isArray(models);\n\t\t\tmodels = singular ? [models] : _.clone(models);\n\t\t\toptions || (options = {});\n\t\t\tvar i, l, index, model;\n\t\t\tfor (i = 0, l = models.length; i < l; i++) {\n\t\t\t\tmodel = models[i] = this.get(models[i]);\n\t\t\t\tif (!model) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdelete this._byId[model.id];\n\t\t\t\tdelete this._byId[model.cid];\n\t\t\t\tindex = this.indexOf(model);\n\t\t\t\tthis.models.splice(index, 1);\n\t\t\t\tthis.length--;\n\t\t\t\tif (!options.silent) {\n\t\t\t\t\toptions.index = index;\n\t\t\t\t\tmodel.trigger('remove', model, this, options);\n\t\t\t\t}\n\t\t\t\tthis._removeReference(model);\n\t\t\t}\n\t\t\treturn singular ? models[0] : models;\n\t\t},\n\n\t\t// Update a collection by `set`-ing a new list of models, adding new ones,\n\t\t// removing models that are no longer present, and merging models that\n\t\t// already exist in the collection, as necessary. Similar to **Model#set**,\n\t\t// the core operation for updating the data contained by the collection.\n\t\tset: function(models, options) {\n\t\t\toptions = _.defaults({}, options, setOptions);\n\t\t\tif (options.parse) {\n\t\t\t\tmodels = this.parse(models, options);\n\t\t\t}\n\t\t\tvar singular = !_.isArray(models);\n\t\t\tmodels = singular ? (models ? [models] : []) : _.clone(models);\n\t\t\tvar i, l, id, model, attrs, existing, sort;\n\t\t\tvar at = options.at;\n\t\t\tvar targetModel = this.model;\n\t\t\tvar sortable = this.comparator && (at == null) && options.sort !== false;\n\t\t\tvar sortAttr = _.isString(this.comparator) ? this.comparator : null;\n\t\t\tvar toAdd = [], toRemove = [], modelMap = {};\n\t\t\tvar add = options.add, merge = options.merge, remove = options.remove;\n\t\t\tvar order = !sortable && add && remove ? [] : false;\n\n\t\t\t// Turn bare objects into model references, and prevent invalid models\n\t\t\t// from being added.\n\t\t\tfor (i = 0, l = models.length; i < l; i++) {\n\t\t\t\tattrs = models[i];\n\t\t\t\tif (attrs instanceof use('spirit.model').Abstract) {\n\t\t\t\t\tid = model = attrs;\n\t\t\t\t} else {\n\t\t\t\t\tid = attrs[targetModel.prototype.idAttribute];\n\t\t\t\t}\n\n\t\t\t\t// If a duplicate is found, prevent it from being added and\n\t\t\t\t// optionally merge it into the existing model.\n\t\t\t\tif (existing = this.get(id)) {\n\t\t\t\t\tif (remove) {\n\t\t\t\t\t\tmodelMap[existing.cid] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (merge) {\n\t\t\t\t\t\tattrs = attrs === model ? model.attributes : attrs;\n\t\t\t\t\t\tif (options.parse) {\n\t\t\t\t\t\t\tattrs = existing.parse(attrs, options);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texisting.set(attrs, options);\n\t\t\t\t\t\tif (sortable && !sort && existing.hasChanged(sortAttr)) {\n\t\t\t\t\t\t\tsort = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmodels[i] = existing;\n\n\t\t\t\t\t// If this is a new, valid model, push it to the `toAdd` list.\n\t\t\t\t} else if (add) {\n\t\t\t\t\tmodel = models[i] = this._prepareModel(attrs, options);\n\t\t\t\t\tif (!model) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ttoAdd.push(model);\n\n\t\t\t\t\t// Listen to added models' events, and index models for lookup by\n\t\t\t\t\t// `id` and by `cid`.\n\t\t\t\t\tmodel.on('all', this._onModelEvent, this);\n\t\t\t\t\tthis._byId[model.cid] = model;\n\t\t\t\t\tif (model.id != null) {\n\t\t\t\t\t\tthis._byId[model.id] = model;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (order) {\n\t\t\t\t\torder.push(existing || model);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove nonexistent models if appropriate.\n\t\t\tif (remove) {\n\t\t\t\tfor (i = 0, l = this.length; i < l; ++i) {\n\t\t\t\t\tif (!modelMap[(model = this.models[i]).cid]) {\n\t\t\t\t\t\ttoRemove.push(model);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (toRemove.length) {\n\t\t\t\t\tthis.remove(toRemove, options);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// See if sorting is needed, update `length` and splice in new models.\n\t\t\tif (toAdd.length || (order && order.length)) {\n\t\t\t\tif (sortable) {\n\t\t\t\t\tsort = true;\n\t\t\t\t}\n\t\t\t\tthis.length += toAdd.length;\n\t\t\t\tif (at != null) {\n\t\t\t\t\tfor (i = 0, l = toAdd.length; i < l; i++) {\n\t\t\t\t\t\tthis.models.splice(at + i, 0, toAdd[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (order) {\n\t\t\t\t\t\tthis.models.length = 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar orderedModels = order || toAdd;\n\t\t\t\t\tfor (i = 0, l = orderedModels.length; i < l; i++) {\n\t\t\t\t\t\tthis.models.push(orderedModels[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Silently sort the collection if appropriate.\n\t\t\tif (sort) {\n\t\t\t\tthis.sort({silent: true});\n\t\t\t}\n\n\t\t\t// Unless silenced, it's time to fire all appropriate add/sort events.\n\t\t\tif (!options.silent) {\n\t\t\t\tfor (i = 0, l = toAdd.length; i < l; i++) {\n\t\t\t\t\t(model = toAdd[i]).trigger('add', model, this, options);\n\t\t\t\t}\n\t\t\t\tif (sort || (order && order.length)) {\n\t\t\t\t\tthis.trigger('sort', this, options);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return the added (or merged) model (or models).\n\t\t\treturn singular ? models[0] : models;\n\t\t},\n\n\t\t// When you have more items than you want to add or remove individually,\n\t\t// you can reset the entire set with a new list of models, without firing\n\t\t// any granular `add` or `remove` events. Fires `reset` when finished.\n\t\t// Useful for bulk operations and optimizations.\n\t\treset: function(models, options) {\n\t\t\toptions || (options = {});\n\t\t\tfor (var i = 0, l = this.models.length; i < l; i++) {\n\t\t\t\tthis._removeReference(this.models[i]);\n\t\t\t}\n\t\t\toptions.previousModels = this.models;\n\t\t\tthis._reset();\n\t\t\tmodels = this.add(models, _.extend({silent: true}, options));\n\t\t\tif (!options.silent) {\n\t\t\t\tthis.trigger('reset', this, options);\n\t\t\t}\n\t\t\treturn models;\n\t\t},\n\n\t\t// Add a model to the end of the collection.\n\t\tpush: function(model, options) {\n\t\t\treturn this.add(model, _.extend({at: this.length}, options));\n\t\t},\n\n\t\t// Remove a model from the end of the collection.\n\t\tpop: function(options) {\n\t\t\tvar model = this.at(this.length - 1);\n\t\t\tthis.remove(model, options);\n\t\t\treturn model;\n\t\t},\n\n\t\t// Add a model to the beginning of the collection.\n\t\tunshift: function(model, options) {\n\t\t\treturn this.add(model, _.extend({at: 0}, options));\n\t\t},\n\n\t\t// Remove a model from the beginning of the collection.\n\t\tshift: function(options) {\n\t\t\tvar model = this.at(0);\n\t\t\tthis.remove(model, options);\n\t\t\treturn model;\n\t\t},\n\n\t\t// Slice out a sub-array of models from the collection.\n\t\tslice: function() {\n\t\t\treturn slice.apply(this.models, arguments);\n\t\t},\n\n\t\t// Get a model from the set by id.\n\t\tget: function(obj) {\n\t\t\tif (obj == null) {\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t\treturn this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];\n\t\t},\n\n\t\t// Get the model at the given index.\n\t\tat: function(index) {\n\t\t\treturn this.models[index];\n\t\t},\n\n\t\t// Return models with matching attributes. Useful for simple cases of\n\t\t// `filter`.\n\t\twhere: function(attrs, first) {\n\t\t\tif (_.isEmpty(attrs)) {\n\t\t\t\treturn first ? void 0 : [];\n\t\t\t}\n\t\t\treturn this[first ? 'find' : 'filter'](function(model) {\n\t\t\t\tfor (var key in attrs) {\n\t\t\t\t\tif (attrs[key] !== model.get(key)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t},\n\n\t\t// Return the first model with matching attributes. Useful for simple cases\n\t\t// of `find`.\n\t\tfindWhere: function(attrs) {\n\t\t\treturn this.where(attrs, true);\n\t\t},\n\n\t\t// Force the collection to re-sort itself. You don't need to call this under\n\t\t// normal circumstances, as the set will maintain sort order as each item\n\t\t// is added.\n\t\tsort: function(options) {\n\t\t\tif (!this.comparator) {\n\t\t\t\tthrow new Error('Cannot sort a set without a comparator');\n\t\t\t}\n\t\t\toptions || (options = {});\n\n\t\t\t// Run sort based on type of `comparator`.\n\t\t\tif (_.isString(this.comparator) || this.comparator.length === 1) {\n\t\t\t\tthis.models = this.sortBy(this.comparator, this);\n\t\t\t} else {\n\t\t\t\tthis.models.sort(_.bind(this.comparator, this));\n\t\t\t}\n\n\t\t\tif (!options.silent) {\n\t\t\t\tthis.trigger('sort', this, options);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t// Pluck an attribute from each model in the collection.\n\t\tpluck: function(attr) {\n\t\t\treturn _.invoke(this.models, 'get', attr);\n\t\t},\n\n\t\t// Create a new instance of a model in this collection. Add the model to the\n\t\t// collection immediately, unless `wait: true` is passed, in which case we\n\t\t// wait for the server to agree.\n\t\tcreate: function(model, options) {\n\t\t\toptions = options ? _.clone(options) : {};\n\t\t\tif (!(model = this._prepareModel(model, options))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!options.wait) {\n\t\t\t\tthis.add(model, options);\n\t\t\t}\n\t\t\tvar collection = this;\n\t\t\tvar success = options.success;\n\t\t\toptions.success = function(model, resp, options) {\n\t\t\t\tif (options.wait) {\n\t\t\t\t\tcollection.add(model, options);\n\t\t\t\t}\n\t\t\t\tif (success) {\n\t\t\t\t\tsuccess(model, resp, options);\n\t\t\t\t}\n\t\t\t};\n\t\t\tmodel.save(null, options);\n\t\t\treturn model;\n\t\t},\n\n\t\t// **parse** converts a response into a list of models to be added to the\n\t\t// collection. The default implementation is just to pass it through.\n\t\tparse: function(resp, options) {\n\t\t\treturn resp;\n\t\t},\n\n\t\t// Create a new collection with an identical list of models as this one.\n\t\tclone: function() {\n\t\t\treturn new this.constructor(this.models);\n\t\t},\n\n\t\t// Private method to reset all internal state. Called when the collection\n\t\t// is first initialized or reset.\n\t\t_reset: function() {\n\t\t\tthis.length = 0;\n\t\t\tthis.models = [];\n\t\t\tthis._byId = {};\n\t\t},\n\n\t\t// Prepare a hash of attributes (or other model) to be added to this\n\t\t// collection.\n\t\t_prepareModel: function(attrs, options) {\n\t\t\tif (attrs instanceof use('spirit.model').Abstract) {\n\t\t\t\tif (!attrs.collection) {\n\t\t\t\t\tattrs.collection = this;\n\t\t\t\t}\n\t\t\t\treturn attrs;\n\t\t\t}\n\t\t\toptions = options ? _.clone(options) : {};\n\t\t\toptions.collection = this;\n\t\t\tvar model = new this.model(attrs, options);\n\t\t\tif (!model.validationError) {\n\t\t\t\treturn model;\n\t\t\t}\n\t\t\tthis.trigger('invalid', this, model.validationError, options);\n\t\t\treturn false;\n\t\t},\n\n\t\t// Internal method to sever a model's ties to a collection.\n\t\t_removeReference: function(model) {\n\t\t\tif (this === model.collection) {\n\t\t\t\tdelete model.collection;\n\t\t\t}\n\t\t\tmodel.off('all', this._onModelEvent, this);\n\t\t},\n\n\t\t// Internal method called every time a model in the set fires an event.\n\t\t// Sets need to update their indexes when models change ids. All other\n\t\t// events simply proxy through. \"add\" and \"remove\" events that originate\n\t\t// in other collections are ignored.\n\t\t_onModelEvent: function(event, model, collection, options) {\n\t\t\tif ((event === 'add' || event === 'remove') && collection !== this) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (event === 'destroy') {\n\t\t\t\tthis.remove(model, options);\n\t\t\t}\n\t\t\tif (model && event === 'change:' + model.idAttribute) {\n\t\t\t\tdelete this._byId[model.previous(model.idAttribute)];\n\t\t\t\tif (model.id != null) {\n\t\t\t\t\tthis._byId[model.id] = model;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.trigger.apply(this, arguments);\n\t\t}\n\n\t});\n\n\t/**\n\t * Mark as parseable\n\t * In model.defaults {} we can provide class, while creating instance defaults will be set\n\t * @type {boolean}\n\t */\n\tns.Abstract.parseable = true;\n\n\t// Underscore methods that we want to implement on the Collection.\n\t// 90% of the core usefulness of Backbone Collections is actually implemented\n\t// right here:\n\tvar methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\n\t               'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\n\t               'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\n\t               'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',\n\t               'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',\n\t               'lastIndexOf', 'isEmpty', 'chain'];\n\n\t// Mix in each Underscore method as a proxy to `Collection#models`.\n\t_.each(methods, function(method) {\n\t\tns.Abstract.prototype[method] = function() {\n\t\t\tvar args = [].slice.call(arguments);\n\t\t\targs.unshift(this.models);\n\t\t\treturn _[method].apply(_, args);\n\t\t};\n\t});\n\n\n\t// Underscore methods that take a property name as an argument.\n\tvar attributeMethods = ['groupBy', 'countBy', 'sortBy'];\n\n\t// Use attributes instead of properties.\n\t_.each(attributeMethods, function(method) {\n\t\tns.Abstract.prototype[method] = function(value, context) {\n\t\t\tvar iterator = _.isFunction(value) ? value : function(model) {\n\t\t\t\treturn model.get(value);\n\t\t\t};\n\t\t\treturn _[method](this.models, iterator, context);\n\t\t};\n\t});\n\n\n})(use('spirit.collection'));\n\n/* jshint ignore:end */\n","(function(ns) {\n\n  'use strict';\n\n  ns.Group = ns.Abstract.extend({\n\n    defaults: {\n      name: 'no title',\n      timelines: 'spirit.collection.Timelines'\n    },\n\n    timeline: new globalDefaults.timeline({ useFrames: true, paused: true }),\n\n    initialize: function(){\n      _.autoBind(this);\n\n      this.get('timelines').on('add reset remove change change:transitions', this.constructTimeline);\n      this.constructTimeline();\n    },\n\n    /**\n     * Create timeline from all timelines in this group\n     * @returns {ns.Group}\n     */\n    constructTimeline: function(){\n      this.timeline.kill();\n      this.timeline.clear();\n\n      this.get('timelines').each(function(tl){\n        this.timeline.add(new (use('spirit.factory').Timeline)(tl.get('el'), tl.get('transitions')).play(), 0);\n      }, this);\n\n      this.trigger('construct:timeline', this.timeline);\n      return this;\n    }\n\n  });\n\n})(use('spirit.model'));\n","(function(ns) {\n\n  'use strict';\n\n  ns.State = ns.Abstract.extend({\n\n    defaults: {\n      name: 'undefined',\n      tweenObj: {}\n    }\n\n  });\n\n})(use('spirit.model'));\n","(function(ns) {\n\n  'use strict';\n\n  ns.Transition = ns.Abstract.extend({\n\n    defaults: {\n      frame: 0,\n      params: 'spirit.collection.TransitionParams',\n      ease: 'Linear.easeNone'\n    },\n\n    initialize: function(){\n      _.autoBind(this);\n\n      // apply bubbling events\n      this.get('params').on('change', _.bind(function(e){\n        this.trigger('change:params', e);\n      }, this));\n    }\n\n  });\n\n})(use('spirit.model'));\n","(function(ns) {\n\n  'use strict';\n\n  /**\n   * Transition Parameter Model\n   * Data Object containing a CSS parameter and it's value\n   * When value is wrapper between { } then it's considered as an evaluated value\n   */\n  ns.TransitionParam = ns.Abstract.extend({\n\n    defaults: {\n      param: null,\n      value: null\n    },\n\n    /**\n     * Check if current parameter is a CSS Transform\n     * @returns {Boolean}\n     */\n    isCSSTransform: function() {\n      var p = ns.TransitionParam.params,\n          transforms = [\n            p.translateX, p.translateY, p.translateZ,\n            p.rotateX, p.rotateY, p.rotateZ,\n            p.skewX, p.skewY,\n            p.scaleX, p.scaleY\n          ];\n\n      return _.contains(transforms, this.get('param'));\n    },\n\n    /**\n     * Check if current value is evaluable\n     * What this means is that the current value does have a reference (js code),\n     * that's get evaluated in time (JIT). Use getValue to retrieve the actual param value instead.\n     * @returns {Boolean}\n     */\n    isEval: function() {\n      /* jshint -W092 */\n      return /\\{(.*?)\\}/.test(this.get('value'));\n    },\n\n    /**\n     * Get the calculated value based on a (collection) mapping\n     * @param mappings {{ expression, map}|[{ expression, map}]}\n     * @returns {*}\n     */\n    getValue: function(mappings) {\n      var v = this.get('value');\n\n      if (this.isEval()) {\n\n        if (mappings) {\n          // store valid mappings\n          var extractionObject = {};\n          _.each(!_.isArray(mappings) ? [mappings] : mappings, function(mapping, i) {\n            if (mapping.expression instanceof RegExp) {\n              if (mapping.expression.global) {\n                mapping.expression.lastIndex = 0;\n              }\n\n              if (mapping.expression.test(v)) {\n                extractionObject[mapping.expression] = mapping;\n              }\n            }\n          });\n\n          // create the evaluated string out of it\n          for (var i in extractionObject) {\n            v = v.replace(extractionObject[i].expression, 'extractionObject[' + i + '].map');\n          }\n        }\n\n        try {\n          /* jshint -W061 */\n          return eval(v);\n        } catch (e) {}\n      }\n\n      return v;\n    }\n\n  });\n\n  /**\n   * List of all possible CSS params\n   * @type {Object}\n   */\n  ns.TransitionParam.params = {\n    autoAlpha: 'autoAlpha',\n    translateX: 'translateX',\n    translateY: 'translateY',\n    translateZ: 'translateZ',\n\n    rotateX: 'rotateX',\n    rotateY: 'rotateY',\n    rotateZ: 'rotateZ',\n\n    skewX: 'skewX',\n    skewY: 'skewY',\n\n    scaleX: 'scaleX',\n    scaleY: 'scaleY',\n\n    opacity: 'opacity',\n\n    transformOrigin: 'transformOrigin',\n    perspective: 'perspective',\n\n    backgroundPositionX: 'backgroundPositionX',\n    backgroundPositionY: 'backgroundPositionY',\n\n    width: 'width',\n    height: 'height',\n\n    color: 'color',\n    backgroundColor: 'backgroundColor',\n\n    paddingTop: 'paddingTop',\n    paddingBottom: 'paddingBottom',\n    paddingLeft: 'paddingLeft',\n    paddingRight: 'paddingRight',\n\n    marginTop: 'marginTop',\n    marginBottom: 'marginBottom',\n    marginLeft: 'marginLeft',\n    marginRight: 'marginRight',\n\n    fontSize: 'fontSize',\n\n    borderWidth: 'borderWidth',\n    borderColor: 'borderColor',\n\n    borderTopWidth: 'borderTopWidth',\n    borderBottomWidth: 'borderBottomWidth',\n    borderLeftWidth: 'borderLeftWidth',\n    borderRightWidth: 'borderRightWidth',\n\n    borderTopColor: 'borderTopColor',\n    borderBottomColor: 'borderBottomColor',\n    borderLeftColor: 'borderLeftColor',\n    borderRightColor: 'borderRightColor',\n\n    borderTopLeftRadius: 'borderTopLeftRadius',\n    borderTopRightRadius: 'borderTopRightRadius',\n    borderBottomRightRadius: 'borderBottomRightRadius',\n    borderBottomLeftRadius: 'borderBottomLeftRadius'\n  };\n\n})(use('spirit.model'));\n","(function(ns) {\n  'use strict';\n\n  ns.RegExpMapping = function(expression, map) {\n\n    this.expression = expression;\n    this.map = map;\n\n  };\n\n})(use('spirit.model.vo'));\n","(function(ns) {\n\n  'use strict';\n\n  ns.Groups = ns.Abstract.extend({\n    model: 'spirit.model.Group',\n\n    /**\n     * Export as valid json\n     */\n    toJSON: function(){\n      var data = [];\n\n      this.each(function(group){\n        data.push({\n          name: group.get('name'),\n          timelines: group.get('timelines').toJSON()\n        });\n      });\n\n      return data;\n    }\n  });\n\n})(use('spirit.collection'));\n","(function(ns) {\n\n\t'use strict';\n\n\tns.States = ns.Abstract.extend({\n\t\tmodel: 'spirit.model.State'\n\t});\n\n})(use('spirit.collection'));\n","(function(ns) {\n\n  'use strict';\n\n  ns.Timelines = ns.Abstract.extend({\n    model: 'spirit.model.Timeline',\n\n    /**\n     * Export to valid JSON\n     * @returns {Array}\n     */\n    toJSON: function(){\n      var data = [];\n\n      this.each(function(timeline){\n        data.push({\n          id: timeline.get('id'),\n          transitions: timeline.get('transitions').toJSON()\n        });\n      });\n\n      return data;\n    }\n  });\n\n})(use('spirit.collection'));\n","(function(ns) {\n\n\t'use strict';\n\n\tns.TransitionParams = ns.Abstract.extend({\n\n\t\tmodel: 'spirit.model.TransitionParam',\n\n\t\t/**\n\t\t * Construct Tween GSAP parameters from current collection\n\t\t * @param evaluationExpressions {Object} evaluation mapping\n\t\t * @returns {Object}\n\t\t */\n\t\tconstructTweenObject: function(evaluationExpressions){\n\n\t\t\tvar constructed = {},\n\t\t\t\tcss = use('spirit.model').TransitionParam.params;\n\n\t\t\t_.each(this.filter(function(param){ return param.get('param') !== null && param.get('value') !== null; }), function(param){\n\t\t\t\tif (param.isCSSTransform()) {\n\t\t\t\t\tswitch(param.get('param')) {\n\t\t\t\t\t\tcase css.translateX: constructed.x = param.getValue(evaluationExpressions); break;\n\t\t\t\t\t\tcase css.translateY: constructed.y = param.getValue(evaluationExpressions); break;\n\t\t\t\t\t\tcase css.translateZ: constructed.z = param.getValue(evaluationExpressions); break;\n\n\t\t\t\t\t\tcase css.rotateX: constructed.rotationX = '+=' + param.getValue(evaluationExpressions) + 'deg'; break;\n\t\t\t\t\t\tcase css.rotateY: constructed.rotationY = '+=' + param.getValue(evaluationExpressions) + 'deg'; break;\n\t\t\t\t\t\tcase css.rotateZ: constructed.rotationZ = '+=' + param.getValue(evaluationExpressions) + 'deg'; break;\n\n\t\t\t\t\t\tcase css.skewX: constructed.skewX = param.getValue(evaluationExpressions) + 'deg'; break;\n\t\t\t\t\t\tcase css.skewY: constructed.skewY = param.getValue(evaluationExpressions) + 'deg'; break;\n\n\t\t\t\t\t\tcase css.scaleX:  constructed.scaleX = param.getValue(evaluationExpressions); break;\n\t\t\t\t\t\tcase css.scaleY:  constructed.scaleY = param.getValue(evaluationExpressions); break;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tconstructed[param.get('param')] = param.getValue(evaluationExpressions);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn constructed;\n\t\t},\n\n    /**\n     * Export to valid JSON\n     * @returns {Array}\n     */\n    toJSON: function(){\n      var data = [];\n\n      this.each(function(param){\n        data.push({\n          param: param.get('param'),\n          value: param.get('value')\n        });\n      });\n\n      return data;\n    }\n\n\t});\n\n})(use('spirit.collection'));\n","(function(ns) {\n\n  'use strict';\n\n  ns.Transitions = ns.Abstract.extend({\n\n    model: 'spirit.model.Transition',\n\n    /**\n     * Regex mappings\n     * Evaluated values are piped through these mappings first\n     */\n    mappings: [],\n    comparator: 'frame',\n\n    /**\n     * Initialize Collection of model.Transition\n     * @returns {ns.Transitions}\n     */\n    initialize: function() {\n      _.autoBind(this);\n      this.mappings = [];\n\n      // make sure each model has always a reference to it's previous one\n      this.on('reset add remove', this.updateAll);\n      return this;\n    },\n\n    /**\n     * Update a single model with previousModel\n     * @param m\n     * @param coll\n     * @param options\n     * @returns {ns.Transitions}\n     */\n    updateModel: function(m, coll, options) {\n      var index = this.indexOf(m),\n          modelAbove;\n\n      if (index > 0) {\n        modelAbove = this.at(index - 1);\n      }\n      m.set({previousModel: modelAbove});\n      return this;\n    },\n\n    /**\n     * Update all models with previousModel\n     * @param m\n     * @param coll\n     * @param options\n     * @returns {ns.Transitions}\n     */\n    updateAll: function() {\n      return this.each(this.updateModel);\n    },\n\n    /**\n     * Export to valid JSON\n     * @returns {Array}\n     */\n    toJSON: function(){\n      var data = [];\n\n      this.each(function(transition){\n        data.push({\n          frame: transition.get('frame'),\n          ease: transition.get('ease'),\n          params: transition.get('params').toJSON()\n        });\n      });\n\n      return data;\n    }\n\n  });\n\n})(use('spirit.collection'));\n","(function() {\n  'use strict';\n\n  /**\n   * Imports\n   * @type {Object}\n   */\n  var model = use('spirit.model'),\n  collection = use('spirit.collection');\n\n  /**\n   * Get tween engine (TweenLite|TweenMax)\n   * @type {Function|Object}\n   */\n  var tweener = globalDefaults.tween;\n\n  /**\n   * Parse string to object conform GSAP properties\n   * @param str {String}\n   * @returns {Object}\n   */\n  var getObjectFromString = function(str) {\n    var obj = {};\n    try {\n      var json = str.replace(/'|\"/g, '').replace(/((?![\\d]+|\\.)[#\\w\\.]+|(\\+|-)?[\\d]+(%|px|em|deg))/g, '\"$1\"');\n      obj = $.parseJSON(json);\n    } catch (e) {}\n\n    return obj;\n  };\n\n  /**\n   * Animate to state\n   *\n   * jQuery.spiritAnimateTo(state, speed, tweenOptions)\n   * jQuery.spiritAnimateTo(speed, tweenOptions)\n   *\n   * @see examples/states\n   * @return {jQuery}\n   */\n  $.fn.spiritAnimateTo = function() {\n    var args = [].slice.call(arguments),\n        isState = function() {\n          return _.isString(args[0]);\n        },\n        isDirect = function() {\n          return _.isNumber(args[0]);\n        };\n\n    if (isState()) {\n      return methods.animateToState.apply(this, [\n        args[0],\n        _.isNumber(args[1]) ? args[1] : defaults.speed,\n        _.isObject(args[2]) ? args[2] : {}\n      ]);\n    } else if (isDirect()) {\n      return methods.animateTo.apply(this, [\n        args[0],\n        _.isObject(args[1]) ? args[1] : {}\n      ]);\n    } else {\n      $.error('invalid function parameters provided for jQuery.spiritAnimateTo. ' +\n      'First param needs to be a state (string) or speed (number)');\n    }\n  };\n\n  /**\n   * Default config\n   * @type {Object}\n   */\n  var defaults = {\n    speed: 1\n  };\n\n  /**\n   * Methods to execute\n   * @type {Object}\n   */\n  var methods = {\n\n    /**\n     * Animate to a state\n     * @param state {String} Name of state\n     * @param speed {Number} Time of animation (seconds)\n     * @param options {Object} Override GSAP properties\n     * @returns {jQuery} Current jQuery (collection) of execution\n     */\n    animateToState: function(state, speed, options) {\n      return this.each(function() {\n\n        var $this = $(this),\n            states = $this.data('spirit-states');\n\n        // parse states\n        if (_.isString(states)) {\n          var coll = new collection.States(),\n              stateObj = getObjectFromString(states);\n\n          if (_.size(stateObj) === 0) {\n            $this.trigger('spirit_error', {msg: 'jQuery.spiritAnimateTo: could not parse states: ' + states });\n            return;\n          }\n\n          _.each(stateObj, function(val, key) {\n            coll.add({\n              name: key,\n              tweenObj: val\n            }, {silent: true});\n          });\n\n          $this.data('spirit-states', coll);\n          states = coll;\n        }\n\n        if (!(states instanceof collection.States)) {\n          $this.trigger('spirit_error', {msg: 'jQuery.spiritAnimateTo: State[' + state + '] not found on element'});\n        } else {\n\n          var found = states.where({name: state});\n          if (found.length === 0) {\n            $this.trigger('spirit_error', {msg: 'jQuery.spiritAnimateTo: State[' + state + '] not found on element'});\n            return;\n          }\n\n          // we found state.. animate it!\n          var tweenObj = _.first(found).get('tweenObj');\n          if (_.isObject(tweenObj)) {\n            methods.animateTo.apply(this, [speed, _.extend(tweenObj, options)]);\n          }\n        }\n      });\n    },\n\n    /**\n     * Execute animation\n     * @param speed {Number} Time of animation\n     * @param tweenObj {Object} GSAP properties\n     * @returns {HTMLElement|jQuery}\n     */\n    animateTo: function(speed, tweenObj) {\n      var animateSingleElement = function() {\n        var $this = $(this);\n        if (tweener) {\n          tweener.to($this, speed, tweenObj);\n        }\n      };\n      return (this instanceof HTMLElement) ? animateSingleElement.call(this) : this.each(animateSingleElement);\n    }\n  };\n\n})();\n","(function(ns) {\n\n  'use strict';\n\n  /**\n   * Use a collection.Groups internally\n   * @private\n   */\n  var groups = new (use('spirit.collection').Groups)();\n  groups.on('add remove reset', function(){\n    ns.groups.length = groups.length;\n  });\n\n  /**\n   * Groups API\n   * @public\n   * @type {Object}\n   */\n  ns.groups = {\n\n    /**\n     * Extension needs direct access to collection\n     */\n    __internals__: groups,\n\n    /**\n     * Number of groups\n     */\n    length: 0,\n\n    /**\n     * Add groups to spirit\n     * @param models {Array|Object}\n     * @param options (optional)\n     * @returns added models {Array}\n     */\n    add: function(models, options){\n      return groups.add(models, options);\n    },\n\n    /**\n     * Get group by name\n     * @param name\n     * @returns {model.Group}\n     */\n    get: function(name){\n      var found = groups.where({name: name});\n      if (found.length > 0) {\n        return found[0];\n      }\n      return null;\n    },\n\n    /**\n     * Get group by index\n     * @param index\n     * @returns {model.Group}\n     */\n    at: function(index){\n      return groups.at(index);\n    }\n  };\n\n  /**\n   * Load spirit groups\n   * @param json\n   * @returns {Array}\n   */\n  ns.load = function(json){\n    return groups.reset(json);\n  };\n\n  /**\n   * Reset spirit, remove all groups\n   * @returns {Array}\n   */\n  ns.reset = function(){\n    return groups.reset();\n  };\n\n  /**\n   * Export all groups\n   * @returns {Object} json\n   */\n  ns.toJSON = function(){\n    return groups.toJSON();\n  };\n\n})(use('spirit', true));\n","\n  /**\n   * Expose spiritLoaded on window and dispatch event\n   * This way we make sure that the chrome extension gets notified\n   */\n  var dispatchLoadedEvent = function(ins){\n    window.spiritLoaded = true;\n    var loadEvt;\n    if (_.isFunction(window.CustomEvent)) {\n      loadEvt = new CustomEvent('spirit-loaded', {detail: ins});\n    }else{\n      loadEvt = document.createEvent('Event');\n      loadEvt.initEvent('spirit-loaded', true, true);\n      loadEvt.detail = ins;\n    }\n    if (loadEvt) {\n      window.dispatchEvent(loadEvt);\n    }\n  };\n\n\t/**\n\t * Finally make spirit namespace available\n\t * if we're running in AMD environment return context as module\n\t * else expose it on global (window) object\n\t */\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine(function() {\n      var ins = context.spirit || {};\n      dispatchLoadedEvent(ins);\n\t\t\treturn ins;\n\t\t});\n\t}else {\n\t\t_.extend(global, context);\n    dispatchLoadedEvent(context.spirit);\n\t}\n\n})(window);\n"],"sourceRoot":"/source/"}